"""
╔══════════════════════════════════════════════════════════════════════╗
║         FOREXIA AI ADVISOR — GEMINI MARKET INTELLIGENCE             ║
║   AI-Powered Market Analysis Integrated Into the Trading Pipeline    ║
╚══════════════════════════════════════════════════════════════════════╝

This engine connects to Google Gemini to provide:
  • Real-time market analysis and commentary for each scanned pair
  • Strategy validation — reviews the rule-based engine's signals
  • Market regime detection (trending, ranging, volatile, calm)
  • Multi-timeframe narrative (what's happening on H1/H4/D1 context)
  • Risk commentary on current open positions

The AI is ADVISORY ONLY — it does NOT execute trades.
The existing rule-based engine remains the decision-maker.
Gemini provides a second opinion and market intelligence layer
displayed on the dashboard.
"""

import logging
import asyncio
import json
import time
from datetime import datetime, timezone
from typing import Optional, Dict, List, Any
from dataclasses import dataclass, field

import httpx

logger = logging.getLogger("forexia.gemini_advisor")

# ─────────────────────────────────────────────────────────────────────
#  DATA STRUCTURES
# ─────────────────────────────────────────────────────────────────────

@dataclass
class AIAnalysis:
    """Result of a Gemini market analysis."""
    symbol: str = ""
    timestamp: str = ""
    market_regime: str = ""          # trending_up, trending_down, ranging, volatile
    bias: str = ""                   # bullish, bearish, neutral
    confidence: float = 0.0          # 0-1 how confident the AI is
    key_levels: List[float] = field(default_factory=list)  # Important price levels
    narrative: str = ""              # Natural language market analysis
    strategy_notes: str = ""         # Strategy-specific insights
    risk_warning: str = ""           # Any risk concerns
    timeframe_context: str = ""      # Multi-TF summary
    trade_idea: str = ""             # AI's suggested approach (advisory only)
    raw_response: str = ""           # Full Gemini response for debugging

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "timestamp": self.timestamp,
            "market_regime": self.market_regime,
            "bias": self.bias,
            "confidence": self.confidence,
            "key_levels": self.key_levels,
            "narrative": self.narrative,
            "strategy_notes": self.strategy_notes,
            "risk_warning": self.risk_warning,
            "timeframe_context": self.timeframe_context,
            "trade_idea": self.trade_idea,
        }


@dataclass
class AISignalReview:
    """AI review of a signal generated by the rule-based engine."""
    symbol: str = ""
    signal_direction: str = ""
    signal_type: str = ""
    ai_agrees: bool = False
    agreement_score: float = 0.0     # -1 (strongly disagree) to +1 (strongly agree)
    reasoning: str = ""
    concerns: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "signal_direction": self.signal_direction,
            "signal_type": self.signal_type,
            "ai_agrees": self.ai_agrees,
            "agreement_score": self.agreement_score,
            "reasoning": self.reasoning,
            "concerns": self.concerns,
        }


# ─────────────────────────────────────────────────────────────────────
#  PROMPTS
# ─────────────────────────────────────────────────────────────────────

SYSTEM_PROMPT = """You are Forexia AI — an expert institutional forex market analyst embedded in a Smart Money trading system. You analyze forex markets through the lens of institutional order flow, liquidity manipulation, and the Hegelian Dialectic framework (Problem → Reaction → Solution).

Your analysis framework:
1. **Hegelian Dialectic**: Asian session (Problem/range-building) → London session (Reaction/stop hunt induction) → New York session (Solution/true reversal)
2. **Smart Money Concepts**: Liquidity sweeps, stop hunts, order blocks, fair value gaps, breaker blocks
3. **Weekly Structure**: 5-Act weekly play — Monday (retail induction), Tuesday (accumulation), Wednesday (midweek reversal/WTF pattern), Thursday (distribution), Friday (profit-taking)
4. **Key Levels**: Previous day high/low, Asian range, weekly open, psychological round numbers
5. **Risk Management**: Capital preservation first, institutional discipline

You respond ONLY in valid JSON. No markdown, no code blocks, no extra text.
Keep narratives concise (2-3 sentences max per field).
Be specific — name exact price levels, candle patterns, and session timing.
Always frame analysis through the institutional manipulation lens, never retail indicators."""

ANALYSIS_PROMPT = """Analyze {symbol} for institutional trading opportunities.

Current Market Data:
- Time: {time_utc} UTC ({session_phase})
- Weekly Act: {weekly_act}
- Current Price: {current_price}
- Today's Range: High {day_high}, Low {day_low}
- Spread: {spread} pips

Recent Price Action (last {candle_count} candles, {timeframe}):
{candle_summary}

Open Positions on {symbol}: {open_positions}

Account State: Balance ${balance}, Equity ${equity}, Open Trades: {open_trades}

Respond in this exact JSON format:
{{
  "market_regime": "trending_up|trending_down|ranging|volatile|calm",
  "bias": "bullish|bearish|neutral",
  "confidence": 0.0 to 1.0,
  "key_levels": [price1, price2, price3],
  "narrative": "2-3 sentence market analysis through institutional lens",
  "strategy_notes": "What the Smart Money is likely doing right now",
  "risk_warning": "Any concerns or reasons to stay out (empty string if none)",
  "timeframe_context": "Higher timeframe context (based on candle structure)",
  "trade_idea": "Specific advisory — what to watch for, where to enter/exit (advisory only, not an order)"
}}"""

SIGNAL_REVIEW_PROMPT = """Review this trading signal generated by the Forexia rule-based engine:

Signal Details:
- Symbol: {symbol}
- Direction: {direction}
- Type: {signal_type}
- Confidence: {confidence:.0%}
- Entry: {entry_price}
- Stop Loss: {stop_loss}
- Take Profit: {take_profit}
- Lot Size: {lot_size}

Market Context:
- Session: {session_phase}
- Weekly Act: {weekly_act}
- Recent candles: {candle_mini}

Do you agree with this trade? Respond in this exact JSON format:
{{
  "ai_agrees": true or false,
  "agreement_score": -1.0 to +1.0,
  "reasoning": "Why you agree/disagree (2-3 sentences)",
  "concerns": "Specific risks or reasons to be cautious (empty string if none)"
}}"""

MARKET_OVERVIEW_PROMPT = """Provide a brief multi-pair market overview for institutional forex trading.

Pairs monitored: {pairs}
Current time: {time_utc} UTC ({session_phase})
Weekly Act: {weekly_act}

For each pair, the latest price and daily range:
{pairs_data}

Account: Balance ${balance}, Equity ${equity}, {open_count} open trades

Provide a concise market overview. Respond in this exact JSON format:
{{
  "market_mood": "risk_on|risk_off|mixed|uncertain",
  "dollar_bias": "strong|weak|neutral",
  "best_opportunities": ["SYMBOL1", "SYMBOL2"],
  "avoid_pairs": ["SYMBOL3"],
  "overview": "3-4 sentence institutional market summary",
  "session_outlook": "What to expect in the current/upcoming session"
}}"""


# ─────────────────────────────────────────────────────────────────────
#  GEMINI AI ADVISOR ENGINE
# ─────────────────────────────────────────────────────────────────────

class GeminiAdvisor:
    """
    Google Gemini-powered market intelligence advisor.
    
    Connects to the Gemini API to provide:
      - Per-pair market analysis
      - Signal validation/review  
      - Market overview across all pairs
      - Real-time commentary for the dashboard
    
    Advisory only — does NOT execute trades.
    """

    # Gemini API endpoint
    API_URL = "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    DEFAULT_MODEL = "gemini-2.0-flash"

    def __init__(self):
        self._api_key: str = ""
        self._model: str = self.DEFAULT_MODEL
        self._enabled: bool = False
        self._client: Optional[httpx.AsyncClient] = None

        # Cache to avoid spamming API
        self._analysis_cache: Dict[str, AIAnalysis] = {}   # symbol → latest analysis
        self._overview_cache: Optional[Dict] = None
        self._last_overview_time: float = 0
        self._signal_reviews: List[AISignalReview] = []     # recent signal reviews

        # Rate limiting
        self._last_call_time: float = 0
        self._min_call_interval: float = 2.0  # Min 2 seconds between calls
        self._daily_calls: int = 0
        self._daily_limit: int = 1400         # Gemini free tier = 1500/day, keep buffer
        self._daily_reset_hour: int = 0       # Reset counter at midnight UTC

        # Background scan
        self._scan_task: Optional[asyncio.Task] = None
        self._scan_interval: int = 300        # Scan all pairs every 5 minutes

        logger.info("Gemini AI Advisor initialized (disabled until API key configured)")

    # ─────────────────────────────────────────────────────────────────
    #  CONFIGURATION
    # ─────────────────────────────────────────────────────────────────

    def configure(self, api_key: str, model: str = ""):
        """Set the Gemini API key and optionally the model."""
        self._api_key = api_key.strip()
        if model:
            self._model = model.strip()
        self._enabled = bool(self._api_key)
        if self._enabled:
            logger.info(f"Gemini AI Advisor: ENABLED (model: {self._model})")
        else:
            logger.info("Gemini AI Advisor: DISABLED (no API key)")

    @property
    def is_enabled(self) -> bool:
        return self._enabled and bool(self._api_key)

    @property
    def status(self) -> Dict[str, Any]:
        return {
            "enabled": self.is_enabled,
            "model": self._model,
            "daily_calls": self._daily_calls,
            "daily_limit": self._daily_limit,
            "cached_analyses": len(self._analysis_cache),
            "signal_reviews": len(self._signal_reviews),
        }

    # ─────────────────────────────────────────────────────────────────
    #  GEMINI API COMMUNICATION
    # ─────────────────────────────────────────────────────────────────

    async def _call_gemini(self, prompt: str, system: str = SYSTEM_PROMPT) -> Optional[str]:
        """
        Send a prompt to Gemini and return the text response.
        Handles rate limiting, error handling, and daily quota.
        """
        if not self.is_enabled:
            return None

        # Rate limiting
        now = time.time()
        elapsed = now - self._last_call_time
        if elapsed < self._min_call_interval:
            await asyncio.sleep(self._min_call_interval - elapsed)

        # Daily quota check
        current_hour = datetime.now(timezone.utc).hour
        if current_hour == self._daily_reset_hour and self._daily_calls > 0:
            # Simple daily reset (resets when we first call at midnight UTC hour)
            if now - self._last_call_time > 3600:
                self._daily_calls = 0

        if self._daily_calls >= self._daily_limit:
            logger.warning("Gemini daily API limit reached — skipping call")
            return None

        url = self.API_URL.format(model=self._model)
        payload = {
            "contents": [
                {
                    "parts": [{"text": prompt}]
                }
            ],
            "systemInstruction": {
                "parts": [{"text": system}]
            },
            "generationConfig": {
                "temperature": 0.3,
                "topP": 0.8,
                "topK": 40,
                "maxOutputTokens": 1024,
                "responseMimeType": "application/json",
            },
        }

        try:
            if not self._client:
                self._client = httpx.AsyncClient(timeout=30)

            resp = await self._client.post(
                f"{url}?key={self._api_key}",
                json=payload,
            )
            self._last_call_time = time.time()
            self._daily_calls += 1

            if resp.status_code == 200:
                data = resp.json()
                # Extract text from Gemini response
                candidates = data.get("candidates", [])
                if candidates:
                    parts = candidates[0].get("content", {}).get("parts", [])
                    if parts:
                        return parts[0].get("text", "")
                logger.warning("Gemini returned empty response")
                return None
            elif resp.status_code == 429:
                logger.warning("Gemini rate limited (429) — backing off")
                self._min_call_interval = min(self._min_call_interval * 2, 30)
                return None
            else:
                logger.error(f"Gemini API error {resp.status_code}: {resp.text[:200]}")
                return None

        except httpx.TimeoutException:
            logger.warning("Gemini API timeout")
            return None
        except Exception as e:
            logger.error(f"Gemini API call failed: {e}")
            return None

    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """Parse JSON from Gemini response, handling common issues."""
        if not text:
            return None
        try:
            # Clean potential markdown wrapping
            cleaned = text.strip()
            if cleaned.startswith("```"):
                lines = cleaned.split("\n")
                cleaned = "\n".join(lines[1:-1]) if len(lines) > 2 else cleaned
            return json.loads(cleaned)
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse Gemini JSON: {e}")
            logger.debug(f"Raw response: {text[:300]}")
            return None

    # ─────────────────────────────────────────────────────────────────
    #  ANALYSIS METHODS
    # ─────────────────────────────────────────────────────────────────

    async def analyze_pair(
        self,
        symbol: str,
        candles: List[Any],
        session_phase: str,
        weekly_act: str,
        account_balance: float = 0,
        account_equity: float = 0,
        open_positions: List[Dict] = None,
        spread: float = 0,
    ) -> Optional[AIAnalysis]:
        """
        Run a full AI analysis on a single pair.
        Returns an AIAnalysis with market regime, bias, narrative, etc.
        """
        if not self.is_enabled:
            return None

        # Build candle summary (last 20 candles compressed)
        candle_lines = []
        recent = candles[-20:] if len(candles) >= 20 else candles
        for c in recent:
            ts = c.timestamp.strftime("%H:%M") if hasattr(c, "timestamp") else ""
            o = getattr(c, "open", 0)
            h = getattr(c, "high", 0)
            l = getattr(c, "low", 0)
            cl = getattr(c, "close", 0)
            body = "▲" if cl > o else "▼" if cl < o else "─"
            candle_lines.append(f"  {ts} O:{o:.5f} H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")

        candle_summary = "\n".join(candle_lines) if candle_lines else "No candle data"

        # Current price
        current_price = getattr(candles[-1], "close", 0) if candles else 0
        day_high = max(getattr(c, "high", 0) for c in candles[-100:]) if candles else 0
        day_low = min(getattr(c, "low", 999) for c in candles[-100:]) if candles else 0

        # Open positions on this symbol
        sym_positions = "None"
        if open_positions:
            pos_list = [p for p in open_positions if (p.get("symbol", "").rstrip(".") == symbol)]
            if pos_list:
                sym_positions = ", ".join(
                    f"{p.get('side', '?')} {p.get('volume', 0)} @ {p.get('open_price', 0):.5f} (P/L: {p.get('profit', 0):.2f})"
                    for p in pos_list
                )

        open_count = len(open_positions) if open_positions else 0

        prompt = ANALYSIS_PROMPT.format(
            symbol=symbol,
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            current_price=f"{current_price:.5f}",
            day_high=f"{day_high:.5f}",
            day_low=f"{day_low:.5f}",
            spread=f"{spread:.1f}",
            candle_count=len(recent),
            timeframe="M1",
            candle_summary=candle_summary,
            open_positions=sym_positions,
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_trades=open_count,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        analysis = AIAnalysis(
            symbol=symbol,
            timestamp=datetime.now(timezone.utc).isoformat(),
            market_regime=parsed.get("market_regime", "unknown"),
            bias=parsed.get("bias", "neutral"),
            confidence=float(parsed.get("confidence", 0)),
            key_levels=[float(x) for x in parsed.get("key_levels", []) if x],
            narrative=parsed.get("narrative", ""),
            strategy_notes=parsed.get("strategy_notes", ""),
            risk_warning=parsed.get("risk_warning", ""),
            timeframe_context=parsed.get("timeframe_context", ""),
            trade_idea=parsed.get("trade_idea", ""),
            raw_response=raw or "",
        )

        # Cache it
        self._analysis_cache[symbol] = analysis
        logger.info(
            f"[GEMINI] {symbol} — Regime: {analysis.market_regime}, "
            f"Bias: {analysis.bias}, Confidence: {analysis.confidence:.0%}"
        )
        return analysis

    async def review_signal(
        self,
        symbol: str,
        direction: str,
        signal_type: str,
        confidence: float,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        lot_size: float,
        session_phase: str,
        weekly_act: str,
        candles: List[Any] = None,
    ) -> Optional[AISignalReview]:
        """
        Ask Gemini to review a signal generated by the rule engine.
        Returns agreement score and reasoning.
        """
        if not self.is_enabled:
            return None

        candle_mini = "N/A"
        if candles and len(candles) >= 5:
            last5 = candles[-5:]
            lines = []
            for c in last5:
                cl = getattr(c, "close", 0)
                h = getattr(c, "high", 0)
                l = getattr(c, "low", 0)
                body = "▲" if cl > getattr(c, "open", 0) else "▼"
                lines.append(f"H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")
            candle_mini = " | ".join(lines)

        prompt = SIGNAL_REVIEW_PROMPT.format(
            symbol=symbol,
            direction=direction,
            signal_type=signal_type,
            confidence=confidence,
            entry_price=f"{entry_price:.5f}",
            stop_loss=f"{stop_loss:.5f}",
            take_profit=f"{take_profit:.5f}",
            lot_size=lot_size,
            session_phase=session_phase,
            weekly_act=weekly_act,
            candle_mini=candle_mini,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        review = AISignalReview(
            symbol=symbol,
            signal_direction=direction,
            signal_type=signal_type,
            ai_agrees=parsed.get("ai_agrees", False),
            agreement_score=float(parsed.get("agreement_score", 0)),
            reasoning=parsed.get("reasoning", ""),
            concerns=parsed.get("concerns", ""),
        )

        # Keep last 20 reviews
        self._signal_reviews.append(review)
        if len(self._signal_reviews) > 20:
            self._signal_reviews = self._signal_reviews[-20:]

        emoji = "✅" if review.ai_agrees else "⚠️"
        logger.info(
            f"[GEMINI] Signal Review {emoji} {symbol} {direction} — "
            f"Score: {review.agreement_score:+.2f}, "
            f"{'AGREES' if review.ai_agrees else 'DISAGREES'}: {review.reasoning[:80]}"
        )
        return review

    async def market_overview(
        self,
        pairs: List[str],
        session_phase: str,
        weekly_act: str,
        pairs_data: Dict[str, Dict] = None,
        account_balance: float = 0,
        account_equity: float = 0,
        open_count: int = 0,
    ) -> Optional[Dict]:
        """
        Generate a multi-pair market overview.
        Cached for 5 minutes to avoid excessive API calls.
        """
        if not self.is_enabled:
            return None

        # Check cache (5 min)
        now = time.time()
        if self._overview_cache and (now - self._last_overview_time) < 300:
            return self._overview_cache

        # Build pairs data summary
        data_lines = []
        if pairs_data:
            for sym, d in pairs_data.items():
                price = d.get("price", 0)
                high = d.get("high", 0)
                low = d.get("low", 0)
                data_lines.append(f"  {sym}: Price={price:.5f}, DayH={high:.5f}, DayL={low:.5f}")
        pairs_str = "\n".join(data_lines) if data_lines else "Price data unavailable"

        prompt = MARKET_OVERVIEW_PROMPT.format(
            pairs=", ".join(pairs),
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            pairs_data=pairs_str,
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_count=open_count,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if parsed:
            parsed["timestamp"] = datetime.now(timezone.utc).isoformat()
            self._overview_cache = parsed
            self._last_overview_time = now
            logger.info(
                f"[GEMINI] Market Overview — Mood: {parsed.get('market_mood')}, "
                f"USD: {parsed.get('dollar_bias')}, "
                f"Best: {parsed.get('best_opportunities')}"
            )

        return parsed

    # ─────────────────────────────────────────────────────────────────
    #  BACKGROUND SCAN LOOP
    # ─────────────────────────────────────────────────────────────────

    async def start_scan_loop(self, orchestrator):
        """Start the background AI analysis loop."""
        if self._scan_task and not self._scan_task.done():
            return
        self._scan_task = asyncio.create_task(self._scan_loop(orchestrator))
        logger.info(f"Gemini AI Scan Loop: STARTED — analyzing every {self._scan_interval}s")

    async def stop_scan_loop(self):
        """Stop the background AI analysis loop."""
        if self._scan_task:
            self._scan_task.cancel()
            try:
                await self._scan_task
            except asyncio.CancelledError:
                pass
            self._scan_task = None
            logger.info("Gemini AI Scan Loop: STOPPED")

    async def _scan_loop(self, orchestrator):
        """Background loop that analyzes all configured pairs with Gemini."""
        while True:
            try:
                await asyncio.sleep(self._scan_interval)

                if not self.is_enabled:
                    continue

                bridge = orchestrator.bridge
                if not bridge or not bridge.is_connected:
                    continue

                settings = orchestrator.settings
                pairs = settings.agent.pairs
                session_phase = orchestrator.dialectic.get_current_phase(
                    datetime.utcnow()
                ).value
                weekly_act = orchestrator.weekly.get_current_act(
                    datetime.utcnow()
                ).value

                account = orchestrator._account
                balance = getattr(account, "balance", 0)
                equity = getattr(account, "equity", 0)

                # Get open positions once
                open_positions = []
                try:
                    open_positions = await bridge.get_open_positions()
                except Exception:
                    pass

                # Collect price data for overview
                pairs_data = {}

                # Analyze each pair
                for symbol in pairs:
                    try:
                        candles = await bridge.get_candles(symbol, "M1", 100)
                        if not candles or len(candles) < 20:
                            continue

                        # Get spread
                        spread = 0
                        try:
                            price_info = await bridge.get_current_price(symbol)
                            if price_info:
                                spread = price_info.get("spread", 0)
                                pairs_data[symbol] = {
                                    "price": price_info.get("bid", 0),
                                    "high": max(getattr(c, "high", 0) for c in candles),
                                    "low": min(getattr(c, "low", 999) for c in candles),
                                }
                        except Exception:
                            pass

                        await self.analyze_pair(
                            symbol=symbol,
                            candles=candles,
                            session_phase=session_phase,
                            weekly_act=weekly_act,
                            account_balance=balance,
                            account_equity=equity,
                            open_positions=open_positions,
                            spread=spread,
                        )

                        # Brief pause between pair analyses to respect rate limits
                        await asyncio.sleep(3)

                    except Exception as e:
                        logger.error(f"Gemini scan error for {symbol}: {e}")

                # Market overview (after individual analyses)
                try:
                    await self.market_overview(
                        pairs=pairs,
                        session_phase=session_phase,
                        weekly_act=weekly_act,
                        pairs_data=pairs_data,
                        account_balance=balance,
                        account_equity=equity,
                        open_count=len(open_positions),
                    )
                except Exception as e:
                    logger.error(f"Gemini market overview error: {e}")

                logger.info(
                    f"[GEMINI] Scan cycle complete — "
                    f"{len(self._analysis_cache)} pairs analyzed, "
                    f"API calls today: {self._daily_calls}/{self._daily_limit}"
                )

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Gemini scan loop error: {e}")
                await asyncio.sleep(30)

    # ─────────────────────────────────────────────────────────────────
    #  DATA ACCESS
    # ─────────────────────────────────────────────────────────────────

    def get_analysis(self, symbol: str) -> Optional[Dict]:
        """Get the latest AI analysis for a symbol."""
        a = self._analysis_cache.get(symbol)
        return a.to_dict() if a else None

    def get_all_analyses(self) -> Dict[str, Dict]:
        """Get all cached AI analyses."""
        return {sym: a.to_dict() for sym, a in self._analysis_cache.items()}

    def get_overview(self) -> Optional[Dict]:
        """Get the latest market overview."""
        return self._overview_cache

    def get_signal_reviews(self, limit: int = 10) -> List[Dict]:
        """Get recent signal reviews."""
        return [r.to_dict() for r in self._signal_reviews[-limit:]]

    def get_full_state(self) -> Dict[str, Any]:
        """Get the complete AI advisor state for the dashboard."""
        return {
            "status": self.status,
            "analyses": self.get_all_analyses(),
            "overview": self.get_overview(),
            "signal_reviews": self.get_signal_reviews(),
        }

    async def cleanup(self):
        """Cleanup resources."""
        await self.stop_scan_loop()
        if self._client:
            await self._client.aclose()
            self._client = None
