"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         FOREXIA AI AGENT â€” GEMINI MARKET INTELLIGENCE & EXECUTION   â•‘
â•‘   AI-Powered Market Analysis + Autonomous Trade Execution            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This engine connects to Google Gemini to provide:
  â€¢ Real-time market analysis and commentary for each scanned pair
  â€¢ Strategy validation â€” reviews the rule-based engine's signals
  â€¢ Market regime detection (trending, ranging, volatile, calm)
  â€¢ Multi-timeframe narrative (what's happening on H1/H4/D1 context)
  â€¢ Risk commentary on current open positions
  â€¢ AUTONOMOUS TRADE EXECUTION â€” AI generates and executes trade signals
    when it identifies high-probability institutional setups

The AI Agent works alongside the rule-based engine:
  - Rule engine scans every 2 minutes (existing pipeline)
  - AI Agent scans every 5 minutes with deeper analysis
  - Both route through the risk manager for proper position sizing
  - All safety guards apply: max trades, spread check, session gate, cooldown
"""

import logging
import asyncio
import json
import time
from datetime import datetime, timezone
from typing import Optional, Dict, List, Any
from dataclasses import dataclass, field

import httpx

logger = logging.getLogger("forexia.gemini_advisor")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  DATA STRUCTURES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dataclass
class AIAnalysis:
    """Result of a Gemini market analysis."""
    symbol: str = ""
    timestamp: str = ""
    market_regime: str = ""          # trending_up, trending_down, ranging, volatile
    bias: str = ""                   # bullish, bearish, neutral
    confidence: float = 0.0          # 0-1 how confident the AI is
    key_levels: List[float] = field(default_factory=list)  # Important price levels
    narrative: str = ""              # Natural language market analysis
    strategy_notes: str = ""         # Strategy-specific insights
    risk_warning: str = ""           # Any risk concerns
    timeframe_context: str = ""      # Multi-TF summary
    trade_idea: str = ""             # AI's suggested approach (advisory only)
    raw_response: str = ""           # Full Gemini response for debugging

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "timestamp": self.timestamp,
            "market_regime": self.market_regime,
            "bias": self.bias,
            "confidence": self.confidence,
            "key_levels": self.key_levels,
            "narrative": self.narrative,
            "strategy_notes": self.strategy_notes,
            "risk_warning": self.risk_warning,
            "timeframe_context": self.timeframe_context,
            "trade_idea": self.trade_idea,
        }


@dataclass
class AISignalReview:
    """AI review of a signal generated by the rule-based engine."""
    symbol: str = ""
    signal_direction: str = ""
    signal_type: str = ""
    ai_agrees: bool = False
    agreement_score: float = 0.0     # -1 (strongly disagree) to +1 (strongly agree)
    reasoning: str = ""
    concerns: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "signal_direction": self.signal_direction,
            "signal_type": self.signal_type,
            "ai_agrees": self.ai_agrees,
            "agreement_score": self.agreement_score,
            "reasoning": self.reasoning,
            "concerns": self.concerns,
        }


@dataclass
class AITradeSignal:
    """A trade signal generated by Gemini AI."""
    symbol: str = ""
    action: str = ""                 # BUY, SELL, PASS
    confidence: float = 0.0
    entry_price: float = 0.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    reasoning: str = ""
    risk_pips: float = 0.0
    reward_pips: float = 0.0
    timestamp: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "action": self.action,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "reasoning": self.reasoning,
            "risk_pips": self.risk_pips,
            "reward_pips": self.reward_pips,
            "timestamp": self.timestamp,
        }


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  PROMPTS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SYSTEM_PROMPT = """You are Forexia AI â€” an expert institutional forex market analyst embedded in a Smart Money trading system. You analyze forex markets through the lens of institutional order flow, liquidity manipulation, and the Hegelian Dialectic framework (Problem â†’ Reaction â†’ Solution).

Your analysis framework:
1. **Hegelian Dialectic**: Asian session (Problem/range-building) â†’ London session (Reaction/stop hunt induction) â†’ New York session (Solution/true reversal)
2. **Smart Money Concepts**: Liquidity sweeps, stop hunts, order blocks, fair value gaps, breaker blocks
3. **Weekly Structure**: 5-Act weekly play â€” Monday (retail induction), Tuesday (accumulation), Wednesday (midweek reversal/WTF pattern), Thursday (distribution), Friday (profit-taking)
4. **Key Levels**: Previous day high/low, Asian range, weekly open, psychological round numbers
5. **Risk Management**: Capital preservation first, institutional discipline

You respond ONLY in valid JSON. No markdown, no code blocks, no extra text.
Keep narratives concise (2-3 sentences max per field).
Be specific â€” name exact price levels, candle patterns, and session timing.
Always frame analysis through the institutional manipulation lens, never retail indicators."""

ANALYSIS_PROMPT = """Analyze {symbol} for institutional trading opportunities.

Current Market Data:
- Time: {time_utc} UTC ({session_phase})
- Weekly Act: {weekly_act}
- Current Price: {current_price}
- Today's Range: High {day_high}, Low {day_low}
- Spread: {spread} pips

Recent Price Action (last {candle_count} candles, {timeframe}):
{candle_summary}

Open Positions on {symbol}: {open_positions}

Account State: Balance ${balance}, Equity ${equity}, Open Trades: {open_trades}

Respond in this exact JSON format:
{{
  "market_regime": "trending_up|trending_down|ranging|volatile|calm",
  "bias": "bullish|bearish|neutral",
  "confidence": 0.0 to 1.0,
  "key_levels": [price1, price2, price3],
  "narrative": "2-3 sentence market analysis through institutional lens",
  "strategy_notes": "What the Smart Money is likely doing right now",
  "risk_warning": "Any concerns or reasons to stay out (empty string if none)",
  "timeframe_context": "Higher timeframe context (based on candle structure)",
  "trade_idea": "Specific advisory â€” what to watch for, where to enter/exit (advisory only, not an order)"
}}"""

SIGNAL_REVIEW_PROMPT = """Review this trading signal generated by the Forexia rule-based engine:

Signal Details:
- Symbol: {symbol}
- Direction: {direction}
- Type: {signal_type}
- Confidence: {confidence:.0%}
- Entry: {entry_price}
- Stop Loss: {stop_loss}
- Take Profit: {take_profit}
- Lot Size: {lot_size}

Market Context:
- Session: {session_phase}
- Weekly Act: {weekly_act}
- Recent candles: {candle_mini}

Do you agree with this trade? Respond in this exact JSON format:
{{
  "ai_agrees": true or false,
  "agreement_score": -1.0 to +1.0,
  "reasoning": "Why you agree/disagree (2-3 sentences)",
  "concerns": "Specific risks or reasons to be cautious (empty string if none)"
}}"""

MARKET_OVERVIEW_PROMPT = """Provide a brief multi-pair market overview for institutional forex trading.

Pairs monitored: {pairs}
Current time: {time_utc} UTC ({session_phase})
Weekly Act: {weekly_act}

For each pair, the latest price and daily range:
{pairs_data}

Account: Balance ${balance}, Equity ${equity}, {open_count} open trades

Provide a concise market overview. Respond in this exact JSON format:
{{
  "market_mood": "risk_on|risk_off|mixed|uncertain",
  "dollar_bias": "strong|weak|neutral",
  "best_opportunities": ["SYMBOL1", "SYMBOL2"],
  "avoid_pairs": ["SYMBOL3"],
  "overview": "3-4 sentence institutional market summary",
  "session_outlook": "What to expect in the current/upcoming session"
}}"""

AI_TRADE_SIGNAL_PROMPT = """You are Forexia AI â€” an institutional forex execution agent. Based on the market analysis below, decide whether to EXECUTE A TRADE or PASS.

YOU MUST ONLY TRADE WHEN THERE IS A HIGH-PROBABILITY SETUP. If unsure, respond with "action": "PASS".

EXECUTION RULES:
1. Only trade when confidence >= 0.75
2. Stop-loss MUST be behind a recent swing high/low or liquidity sweep point
3. Take-profit between 8-15 pips for scalps (M1), or 1:2 R:R minimum for swings
4. NEVER trade against the dominant institutional bias
5. Prefer entries after a liquidity sweep (stop hunt) has occurred
6. Risk max 2% of account per trade

Market Data for {symbol}:
- Time: {time_utc} UTC ({session_phase})
- Weekly Act: {weekly_act}
- Current Price: {current_price}
- Bid: {bid}, Ask: {ask}
- Today's Range: High {day_high}, Low {day_low}
- Spread: {spread} pips
- Account Balance: ${balance}, Equity: ${equity}
- Open Trades: {open_trades}
- Existing position on {symbol}: {existing_position}

Recent Price Action (last {candle_count} candles, {timeframe}):
{candle_summary}

Your AI Analysis for this pair:
- Regime: {ai_regime}
- Bias: {ai_bias}
- Confidence: {ai_confidence}
- Narrative: {ai_narrative}
- Key Levels: {ai_key_levels}

Respond in this EXACT JSON format:
{{
  "action": "BUY" or "SELL" or "PASS",
  "confidence": 0.0 to 1.0,
  "entry_price": current_price or specific level,
  "stop_loss": price level (MUST be behind swing point),
  "take_profit": price level,
  "reasoning": "1-2 sentence institutional reasoning for this trade",
  "risk_pips": number of pips risked,
  "reward_pips": number of pips targeted
}}"""


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  GEMINI AI ADVISOR ENGINE
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GeminiAdvisor:
    """
    Google Gemini-powered market intelligence and trade execution agent.
    
    Connects to the Gemini API to provide:
      - Per-pair market analysis
      - Signal validation/review  
      - Market overview across all pairs
      - AI-generated trade signals (executes via orchestrator)
      - Real-time commentary for the dashboard
    """

    # Gemini API endpoint
    API_URL = "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    DEFAULT_MODEL = "gemini-2.5-flash"

    # Model fallback chain: try primary model first, then fallbacks
    # Each model has different free tier quotas (per-model-per-day)
    FALLBACK_MODELS = [
        "gemini-2.5-flash",       # 25 RPD free tier
        "gemini-2.0-flash",       # 1500 RPD free tier (when available)
        "gemini-2.0-flash-lite",  # Higher RPD free tier
        "gemma-3-27b-it",         # Generous free tier (no systemInstruction/JSON mode)
    ]

    # Models that DON'T support systemInstruction or responseMimeType: "application/json"
    BASIC_MODELS = {"gemma-3-27b-it", "gemma-3-12b-it", "gemma-3-4b-it", "gemma-3-1b-it"}

    def __init__(self):
        self._api_key: str = ""
        self._model: str = self.DEFAULT_MODEL
        self._enabled: bool = False
        self._client: Optional[httpx.AsyncClient] = None

        # Cache to avoid spamming API
        self._analysis_cache: Dict[str, AIAnalysis] = {}   # symbol â†’ latest analysis
        self._overview_cache: Optional[Dict] = None
        self._last_overview_time: float = 0
        self._signal_reviews: List[AISignalReview] = []     # recent signal reviews
        self._ai_trade_signals: List[AITradeSignal] = []    # recent AI trade signals

        # Rate limiting
        self._last_call_time: float = 0
        self._min_call_interval: float = 2.0  # Min 2 seconds between calls
        self._daily_calls: int = 0
        self._daily_limit: int = 1400         # Gemini free tier = 1500/day, keep buffer
        self._daily_reset_hour: int = 0       # Reset counter at midnight UTC

        # Track which models are temporarily exhausted (model â†’ retry_after_time)
        self._model_exhausted: Dict[str, float] = {}

        # Background scan
        self._scan_task: Optional[asyncio.Task] = None
        self._scan_interval: int = 300        # Scan all pairs every 5 minutes

        logger.info("Gemini AI Advisor initialized (disabled until API key configured)")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  CONFIGURATION
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def configure(self, api_key: str, model: str = ""):
        """Set the Gemini API key and optionally the model."""
        self._api_key = api_key.strip()
        if model:
            self._model = model.strip()
        self._enabled = bool(self._api_key)
        if self._enabled:
            logger.info(f"Gemini AI Advisor: ENABLED (model: {self._model})")
        else:
            logger.info("Gemini AI Advisor: DISABLED (no API key)")

    @property
    def is_enabled(self) -> bool:
        return self._enabled and bool(self._api_key)

    @property
    def status(self) -> Dict[str, Any]:
        now = time.time()
        exhausted_models = [m for m, t in self._model_exhausted.items() if now < t]
        return {
            "enabled": self.is_enabled,
            "model": self._model,
            "daily_calls": self._daily_calls,
            "daily_limit": self._daily_limit,
            "cached_analyses": len(self._analysis_cache),
            "signal_reviews": len(self._signal_reviews),
            "ai_trades_generated": len(self._ai_trade_signals),
            "exhausted_models": exhausted_models,
            "fallback_chain": self.FALLBACK_MODELS,
        }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  GEMINI API COMMUNICATION
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _call_gemini(self, prompt: str, system: str = SYSTEM_PROMPT) -> Optional[str]:
        """
        Send a prompt to Gemini and return the text response.
        Implements model fallback chain: tries configured model first,
        then falls back through alternate models when rate-limited (429).
        Handles rate limiting, error handling, and daily quota.
        """
        if not self.is_enabled:
            return None

        # Rate limiting
        now = time.time()
        elapsed = now - self._last_call_time
        if elapsed < self._min_call_interval:
            await asyncio.sleep(self._min_call_interval - elapsed)

        # Daily quota check
        current_hour = datetime.now(timezone.utc).hour
        if current_hour == self._daily_reset_hour and self._daily_calls > 0:
            if now - self._last_call_time > 3600:
                self._daily_calls = 0

        if self._daily_calls >= self._daily_limit:
            logger.warning("Gemini daily API limit reached â€” skipping call")
            return None

        # Build fallback chain: primary model first, then fallbacks
        models_to_try = [self._model]
        for m in self.FALLBACK_MODELS:
            if m != self._model and m not in models_to_try:
                models_to_try.append(m)

        if not self._client:
            self._client = httpx.AsyncClient(timeout=60)

        for model in models_to_try:
            # Skip models that are known to be exhausted (with retry-after)
            exhausted_until = self._model_exhausted.get(model, 0)
            if time.time() < exhausted_until:
                continue

            is_basic = model in self.BASIC_MODELS
            url = self.API_URL.format(model=model)

            # Build payload â€” basic models don't support systemInstruction or JSON mode
            if is_basic:
                # Prepend system prompt into the user prompt for basic models
                combined_prompt = f"{system}\n\n---\n\nIMPORTANT: Return ONLY valid JSON. No markdown, no code blocks, no explanation.\n\n{prompt}"
                payload = {
                    "contents": [{"parts": [{"text": combined_prompt}]}],
                    "generationConfig": {
                        "temperature": 0.3,
                        "topP": 0.8,
                        "topK": 40,
                        "maxOutputTokens": 8192,
                    },
                }
            else:
                payload = {
                    "contents": [{"parts": [{"text": prompt}]}],
                    "systemInstruction": {"parts": [{"text": system}]},
                    "generationConfig": {
                        "temperature": 0.3,
                        "topP": 0.8,
                        "topK": 40,
                        "maxOutputTokens": 8192,
                        "responseMimeType": "application/json",
                        "thinkingConfig": {"thinkingBudget": 0},
                    },
                }

            try:
                resp = await self._client.post(
                    f"{url}?key={self._api_key}",
                    json=payload,
                )
                self._last_call_time = time.time()
                self._daily_calls += 1

                if resp.status_code == 200:
                    data = resp.json()
                    candidates = data.get("candidates", [])
                    if candidates:
                        parts = candidates[0].get("content", {}).get("parts", [])
                        if parts:
                            result = parts[0].get("text", "")
                            if model != self._model:
                                logger.info(f"Gemini fallback succeeded with model: {model}")
                            return result
                    logger.warning(f"Gemini ({model}) returned empty response")
                    continue

                elif resp.status_code == 429:
                    # Extract retry delay from response if available
                    retry_delay = 60  # Default 60s backoff
                    try:
                        err_data = resp.json()
                        details = err_data.get("error", {}).get("details", [])
                        for d in details:
                            if d.get("@type", "").endswith("RetryInfo"):
                                delay_str = d.get("retryDelay", "60s")
                                retry_delay = int(float(delay_str.rstrip("s")))
                                break
                    except Exception:
                        pass

                    self._model_exhausted[model] = time.time() + retry_delay
                    logger.warning(f"Gemini ({model}) rate limited (429) â€” blocked for {retry_delay}s, trying next model...")
                    continue

                else:
                    logger.error(f"Gemini ({model}) API error {resp.status_code}: {resp.text[:200]}")
                    continue

            except httpx.TimeoutException:
                logger.warning(f"Gemini ({model}) API timeout â€” trying next model...")
                continue
            except Exception as e:
                logger.error(f"Gemini ({model}) API call failed: {e}")
                continue

        # All models exhausted
        logger.warning("All Gemini/Gemma models exhausted â€” no AI response available")
        return None

    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """Parse JSON from Gemini response, handling common issues."""
        if not text:
            return None
        try:
            # Clean potential markdown wrapping
            cleaned = text.strip()
            if cleaned.startswith("```"):
                lines = cleaned.split("\n")
                cleaned = "\n".join(lines[1:-1]) if len(lines) > 2 else cleaned
            return json.loads(cleaned)
        except json.JSONDecodeError as e:
            # Try to extract JSON object from mixed text
            try:
                start = text.index("{")
                end = text.rindex("}") + 1
                return json.loads(text[start:end])
            except (ValueError, json.JSONDecodeError):
                pass
            logger.warning(f"Failed to parse Gemini JSON: {e}")
            logger.warning(f"Raw response (first 500 chars): {text[:500]}")
            return None

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  ANALYSIS METHODS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def analyze_pair(
        self,
        symbol: str,
        candles: List[Any],
        session_phase: str,
        weekly_act: str,
        account_balance: float = 0,
        account_equity: float = 0,
        open_positions: List[Dict] = None,
        spread: float = 0,
    ) -> Optional[AIAnalysis]:
        """
        Run a full AI analysis on a single pair.
        Returns an AIAnalysis with market regime, bias, narrative, etc.
        """
        if not self.is_enabled:
            return None

        # Build candle summary (last 20 candles compressed)
        candle_lines = []
        recent = candles[-20:] if len(candles) >= 20 else candles
        for c in recent:
            ts = c.timestamp.strftime("%H:%M") if hasattr(c, "timestamp") else ""
            o = getattr(c, "open", 0)
            h = getattr(c, "high", 0)
            l = getattr(c, "low", 0)
            cl = getattr(c, "close", 0)
            body = "â–²" if cl > o else "â–¼" if cl < o else "â”€"
            candle_lines.append(f"  {ts} O:{o:.5f} H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")

        candle_summary = "\n".join(candle_lines) if candle_lines else "No candle data"

        # Current price
        current_price = getattr(candles[-1], "close", 0) if candles else 0
        day_high = max(getattr(c, "high", 0) for c in candles[-100:]) if candles else 0
        day_low = min(getattr(c, "low", 999) for c in candles[-100:]) if candles else 0

        # Open positions on this symbol
        sym_positions = "None"
        if open_positions:
            pos_list = [p for p in open_positions if (p.get("symbol", "").rstrip(".") == symbol)]
            if pos_list:
                sym_positions = ", ".join(
                    f"{p.get('side', '?')} {p.get('volume', 0)} @ {p.get('open_price', 0):.5f} (P/L: {p.get('profit', 0):.2f})"
                    for p in pos_list
                )

        open_count = len(open_positions) if open_positions else 0

        prompt = ANALYSIS_PROMPT.format(
            symbol=symbol,
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            current_price=f"{current_price:.5f}",
            day_high=f"{day_high:.5f}",
            day_low=f"{day_low:.5f}",
            spread=f"{spread:.1f}",
            candle_count=len(recent),
            timeframe="M1",
            candle_summary=candle_summary,
            open_positions=sym_positions,
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_trades=open_count,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        analysis = AIAnalysis(
            symbol=symbol,
            timestamp=datetime.now(timezone.utc).isoformat(),
            market_regime=parsed.get("market_regime", "unknown"),
            bias=parsed.get("bias", "neutral"),
            confidence=float(parsed.get("confidence", 0)),
            key_levels=[float(x) for x in parsed.get("key_levels", []) if x],
            narrative=parsed.get("narrative", ""),
            strategy_notes=parsed.get("strategy_notes", ""),
            risk_warning=parsed.get("risk_warning", ""),
            timeframe_context=parsed.get("timeframe_context", ""),
            trade_idea=parsed.get("trade_idea", ""),
            raw_response=raw or "",
        )

        # Cache it
        self._analysis_cache[symbol] = analysis
        logger.info(
            f"[GEMINI] {symbol} â€” Regime: {analysis.market_regime}, "
            f"Bias: {analysis.bias}, Confidence: {analysis.confidence:.0%}"
        )
        return analysis

    async def review_signal(
        self,
        symbol: str,
        direction: str,
        signal_type: str,
        confidence: float,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        lot_size: float,
        session_phase: str,
        weekly_act: str,
        candles: List[Any] = None,
    ) -> Optional[AISignalReview]:
        """
        Ask Gemini to review a signal generated by the rule engine.
        Returns agreement score and reasoning.
        """
        if not self.is_enabled:
            return None

        candle_mini = "N/A"
        if candles and len(candles) >= 5:
            last5 = candles[-5:]
            lines = []
            for c in last5:
                cl = getattr(c, "close", 0)
                h = getattr(c, "high", 0)
                l = getattr(c, "low", 0)
                body = "â–²" if cl > getattr(c, "open", 0) else "â–¼"
                lines.append(f"H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")
            candle_mini = " | ".join(lines)

        prompt = SIGNAL_REVIEW_PROMPT.format(
            symbol=symbol,
            direction=direction,
            signal_type=signal_type,
            confidence=confidence,
            entry_price=f"{entry_price:.5f}",
            stop_loss=f"{stop_loss:.5f}",
            take_profit=f"{take_profit:.5f}",
            lot_size=lot_size,
            session_phase=session_phase,
            weekly_act=weekly_act,
            candle_mini=candle_mini,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        review = AISignalReview(
            symbol=symbol,
            signal_direction=direction,
            signal_type=signal_type,
            ai_agrees=parsed.get("ai_agrees", False),
            agreement_score=float(parsed.get("agreement_score", 0)),
            reasoning=parsed.get("reasoning", ""),
            concerns=parsed.get("concerns", ""),
        )

        # Keep last 20 reviews
        self._signal_reviews.append(review)
        if len(self._signal_reviews) > 20:
            self._signal_reviews = self._signal_reviews[-20:]

        emoji = "âœ…" if review.ai_agrees else "âš ï¸"
        logger.info(
            f"[GEMINI] Signal Review {emoji} {symbol} {direction} â€” "
            f"Score: {review.agreement_score:+.2f}, "
            f"{'AGREES' if review.ai_agrees else 'DISAGREES'}: {review.reasoning[:80]}"
        )
        return review

    async def generate_trade_signal(
        self,
        symbol: str,
        candles: List[Any],
        session_phase: str,
        weekly_act: str,
        account_balance: float = 0,
        account_equity: float = 0,
        open_positions: List[Dict] = None,
        spread: float = 0,
        bid: float = 0,
        ask: float = 0,
    ) -> Optional[AITradeSignal]:
        """
        Ask Gemini to generate an actionable trade signal.
        Returns AITradeSignal with BUY/SELL/PASS decision and levels.
        This is called after analyze_pair for high-confidence setups.
        """
        if not self.is_enabled:
            return None

        # Get the cached analysis for this symbol
        cached = self._analysis_cache.get(symbol)
        if not cached:
            return None

        # Only attempt trades when AI analysis confidence is >= 0.65
        if cached.confidence < 0.65:
            return None

        # Build candle summary
        candle_lines = []
        recent = candles[-30:] if len(candles) >= 30 else candles
        for c in recent:
            ts = c.timestamp.strftime("%H:%M") if hasattr(c, "timestamp") else ""
            o = getattr(c, "open", 0)
            h = getattr(c, "high", 0)
            l = getattr(c, "low", 0)
            cl = getattr(c, "close", 0)
            body = "â–²" if cl > o else "â–¼" if cl < o else "â”€"
            candle_lines.append(f"  {ts} O:{o:.5f} H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")
        candle_summary = "\n".join(candle_lines) if candle_lines else "No candle data"

        current_price = getattr(candles[-1], "close", 0) if candles else 0
        day_high = max(getattr(c, "high", 0) for c in candles[-100:]) if candles else 0
        day_low = min(getattr(c, "low", 999) for c in candles[-100:]) if candles else 0

        # Check existing position
        existing = "None"
        if open_positions:
            pos_list = [p for p in open_positions if (p.get("symbol", "").rstrip(".") == symbol)]
            if pos_list:
                existing = ", ".join(
                    f"{p.get('side', '?')} {p.get('volume', 0)} @ {p.get('open_price', 0):.5f}"
                    for p in pos_list
                )

        open_count = len(open_positions) if open_positions else 0

        prompt = AI_TRADE_SIGNAL_PROMPT.format(
            symbol=symbol,
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            current_price=f"{current_price:.5f}",
            bid=f"{bid:.5f}" if bid else f"{current_price:.5f}",
            ask=f"{ask:.5f}" if ask else f"{current_price:.5f}",
            day_high=f"{day_high:.5f}",
            day_low=f"{day_low:.5f}",
            spread=f"{spread:.1f}",
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_trades=open_count,
            existing_position=existing,
            candle_count=len(recent),
            timeframe="M1",
            candle_summary=candle_summary,
            ai_regime=cached.market_regime,
            ai_bias=cached.bias,
            ai_confidence=f"{cached.confidence:.0%}",
            ai_narrative=cached.narrative,
            ai_key_levels=", ".join(f"{lv:.5f}" for lv in cached.key_levels) if cached.key_levels else "None",
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        action = parsed.get("action", "PASS").upper()
        if action not in ("BUY", "SELL"):
            logger.info(f"[GEMINI] {symbol} â€” AI decided to PASS (no trade)")
            return None

        signal = AITradeSignal(
            symbol=symbol,
            action=action,
            confidence=float(parsed.get("confidence", 0)),
            entry_price=float(parsed.get("entry_price", current_price)),
            stop_loss=float(parsed.get("stop_loss", 0)),
            take_profit=float(parsed.get("take_profit", 0)),
            reasoning=parsed.get("reasoning", ""),
            risk_pips=float(parsed.get("risk_pips", 0)),
            reward_pips=float(parsed.get("reward_pips", 0)),
            timestamp=datetime.now(timezone.utc).isoformat(),
        )

        # Validate: must have SL and TP
        if signal.stop_loss <= 0 or signal.take_profit <= 0:
            logger.warning(f"[GEMINI] {symbol} â€” AI signal missing SL/TP, discarding")
            return None

        # Validate: minimum confidence
        if signal.confidence < 0.75:
            logger.info(f"[GEMINI] {symbol} â€” AI confidence too low ({signal.confidence:.0%}), skipping")
            return None

        # Store for dashboard
        self._ai_trade_signals.append(signal)
        if len(self._ai_trade_signals) > 30:
            self._ai_trade_signals = self._ai_trade_signals[-30:]

        logger.info(
            f"[GEMINI] ðŸ”¥ AI TRADE SIGNAL: {action} {symbol} @ {signal.entry_price:.5f} | "
            f"SL: {signal.stop_loss:.5f} | TP: {signal.take_profit:.5f} | "
            f"Conf: {signal.confidence:.0%} | {signal.reasoning[:80]}"
        )
        return signal

    async def market_overview(
        self,
        pairs: List[str],
        session_phase: str,
        weekly_act: str,
        pairs_data: Dict[str, Dict] = None,
        account_balance: float = 0,
        account_equity: float = 0,
        open_count: int = 0,
    ) -> Optional[Dict]:
        """
        Generate a multi-pair market overview.
        Cached for 5 minutes to avoid excessive API calls.
        """
        if not self.is_enabled:
            return None

        # Check cache (5 min)
        now = time.time()
        if self._overview_cache and (now - self._last_overview_time) < 300:
            return self._overview_cache

        # Build pairs data summary
        data_lines = []
        if pairs_data:
            for sym, d in pairs_data.items():
                price = d.get("price", 0)
                high = d.get("high", 0)
                low = d.get("low", 0)
                data_lines.append(f"  {sym}: Price={price:.5f}, DayH={high:.5f}, DayL={low:.5f}")
        pairs_str = "\n".join(data_lines) if data_lines else "Price data unavailable"

        prompt = MARKET_OVERVIEW_PROMPT.format(
            pairs=", ".join(pairs),
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            pairs_data=pairs_str,
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_count=open_count,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if parsed:
            parsed["timestamp"] = datetime.now(timezone.utc).isoformat()
            self._overview_cache = parsed
            self._last_overview_time = now
            logger.info(
                f"[GEMINI] Market Overview â€” Mood: {parsed.get('market_mood')}, "
                f"USD: {parsed.get('dollar_bias')}, "
                f"Best: {parsed.get('best_opportunities')}"
            )

        return parsed

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  BACKGROUND SCAN LOOP
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def start_scan_loop(self, orchestrator):
        """Start the background AI analysis loop."""
        if self._scan_task and not self._scan_task.done():
            return
        self._scan_task = asyncio.create_task(self._scan_loop(orchestrator))
        logger.info(f"Gemini AI Scan Loop: STARTED â€” analyzing every {self._scan_interval}s")

    async def stop_scan_loop(self):
        """Stop the background AI analysis loop."""
        if self._scan_task:
            self._scan_task.cancel()
            try:
                await self._scan_task
            except asyncio.CancelledError:
                pass
            self._scan_task = None
            logger.info("Gemini AI Scan Loop: STOPPED")

    async def _scan_loop(self, orchestrator):
        """Background loop that analyzes all configured pairs with Gemini."""
        while True:
            try:
                await asyncio.sleep(self._scan_interval)

                if not self.is_enabled:
                    continue

                bridge = orchestrator.bridge
                if not bridge or not bridge.is_connected:
                    continue

                settings = orchestrator.settings
                pairs = settings.agent.pairs
                session_phase = orchestrator.dialectic.get_current_phase(
                    datetime.utcnow()
                ).value
                weekly_act = orchestrator.weekly.get_current_act(
                    datetime.utcnow()
                ).value

                account = orchestrator._account
                balance = getattr(account, "balance", 0)
                equity = getattr(account, "equity", 0)

                # Get open positions once
                open_positions = []
                try:
                    open_positions = await bridge.get_open_positions()
                except Exception:
                    pass

                # Collect price data for overview
                pairs_data = {}

                # Check which symbols already have open positions
                open_symbols = set()
                for pos in open_positions:
                    sym = (pos.get("symbol") or "").rstrip(".")
                    if sym:
                        open_symbols.add(sym)

                # Analyze each pair
                for symbol in pairs:
                    try:
                        candles = await bridge.get_candles(symbol, "M1", 100)
                        if not candles or len(candles) < 20:
                            continue

                        # Get spread and price
                        spread = 0
                        bid = 0
                        ask = 0
                        try:
                            price_info = await bridge.get_current_price(symbol)
                            if price_info:
                                spread = price_info.get("spread", 0)
                                bid = price_info.get("bid", 0)
                                ask = price_info.get("ask", 0)
                                pairs_data[symbol] = {
                                    "price": bid,
                                    "high": max(getattr(c, "high", 0) for c in candles),
                                    "low": min(getattr(c, "low", 999) for c in candles),
                                }
                        except Exception:
                            pass

                        # Step 1: Analyze the pair
                        analysis = await self.analyze_pair(
                            symbol=symbol,
                            candles=candles,
                            session_phase=session_phase,
                            weekly_act=weekly_act,
                            account_balance=balance,
                            account_equity=equity,
                            open_positions=open_positions,
                            spread=spread,
                        )

                        # Step 2: If auto_trade is ON and no existing position,
                        #          ask AI for a trade signal
                        if (settings.agent.auto_trade
                                and symbol not in open_symbols
                                and analysis
                                and analysis.confidence >= 0.65
                                and spread <= settings.risk.max_spread_pips):
                            try:
                                await asyncio.sleep(2)  # Rate limit pause
                                trade_signal = await self.generate_trade_signal(
                                    symbol=symbol,
                                    candles=candles,
                                    session_phase=session_phase,
                                    weekly_act=weekly_act,
                                    account_balance=balance,
                                    account_equity=equity,
                                    open_positions=open_positions,
                                    spread=spread,
                                    bid=bid,
                                    ask=ask,
                                )
                                if trade_signal:
                                    # Execute via orchestrator
                                    executed = await orchestrator.execute_ai_signal(trade_signal)
                                    if executed:
                                        open_symbols.add(symbol)
                            except Exception as e:
                                logger.error(f"Gemini trade signal error for {symbol}: {e}")

                        # Brief pause between pair analyses to respect rate limits
                        await asyncio.sleep(3)

                    except Exception as e:
                        logger.error(f"Gemini scan error for {symbol}: {e}")

                # Market overview (after individual analyses)
                try:
                    await self.market_overview(
                        pairs=pairs,
                        session_phase=session_phase,
                        weekly_act=weekly_act,
                        pairs_data=pairs_data,
                        account_balance=balance,
                        account_equity=equity,
                        open_count=len(open_positions),
                    )
                except Exception as e:
                    logger.error(f"Gemini market overview error: {e}")

                logger.info(
                    f"[GEMINI] Scan cycle complete â€” "
                    f"{len(self._analysis_cache)} pairs analyzed, "
                    f"API calls today: {self._daily_calls}/{self._daily_limit}"
                )

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Gemini scan loop error: {e}")
                await asyncio.sleep(30)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  DATA ACCESS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_analysis(self, symbol: str) -> Optional[Dict]:
        """Get the latest AI analysis for a symbol."""
        a = self._analysis_cache.get(symbol)
        return a.to_dict() if a else None

    def get_all_analyses(self) -> Dict[str, Dict]:
        """Get all cached AI analyses."""
        return {sym: a.to_dict() for sym, a in self._analysis_cache.items()}

    def get_overview(self) -> Optional[Dict]:
        """Get the latest market overview."""
        return self._overview_cache

    def get_signal_reviews(self, limit: int = 10) -> List[Dict]:
        """Get recent signal reviews."""
        return [r.to_dict() for r in self._signal_reviews[-limit:]]

    def get_ai_trade_signals(self, limit: int = 10) -> List[Dict]:
        """Get recent AI-generated trade signals."""
        return [s.to_dict() for s in self._ai_trade_signals[-limit:]]

    def get_full_state(self) -> Dict[str, Any]:
        """Get the complete AI advisor state for the dashboard."""
        return {
            "status": self.status,
            "analyses": self.get_all_analyses(),
            "overview": self.get_overview(),
            "signal_reviews": self.get_signal_reviews(),
            "ai_trade_signals": self.get_ai_trade_signals(),
        }

    async def cleanup(self):
        """Cleanup resources."""
        await self.stop_scan_loop()
        if self._client:
            await self._client.aclose()
            self._client = None
