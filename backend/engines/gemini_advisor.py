"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         FOREXIA AI AGENT â€” GEMINI MARKET INTELLIGENCE & EXECUTION   â•‘
â•‘   AI-Powered Market Analysis + Autonomous Trade Execution            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This engine connects to Google Gemini to provide:
  â€¢ Real-time market analysis and commentary for each scanned pair
  â€¢ Strategy validation â€” reviews the rule-based engine's signals
  â€¢ Market regime detection (trending, ranging, volatile, calm)
  â€¢ Multi-timeframe narrative (what's happening on H1/H4/D1 context)
  â€¢ Risk commentary on current open positions
  â€¢ AUTONOMOUS TRADE EXECUTION â€” AI generates and executes trade signals
    when it identifies high-probability institutional setups

The AI Agent works alongside the rule-based engine:
  - Rule engine scans every 2 minutes (existing pipeline)
  - AI Agent scans every 5 minutes with deeper analysis
  - Both route through the risk manager for proper position sizing
  - All safety guards apply: max trades, spread check, session gate, cooldown
"""

import logging
import asyncio
import json
import time
from datetime import datetime, timezone
from typing import Optional, Dict, List, Any
from dataclasses import dataclass, field

import httpx

from backend.engines.market_structure import MarketStructureAnalyzer, MarketStructure

logger = logging.getLogger("forexia.gemini_advisor")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  DATA STRUCTURES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dataclass
class AIAnalysis:
    """Result of a Gemini market analysis."""
    symbol: str = ""
    timestamp: str = ""
    market_regime: str = ""          # trending_up, trending_down, ranging, volatile
    bias: str = ""                   # bullish, bearish, neutral
    confidence: float = 0.0          # 0-1 how confident the AI is
    key_levels: List[float] = field(default_factory=list)  # Important price levels
    narrative: str = ""              # Natural language market analysis
    strategy_notes: str = ""         # Strategy-specific insights
    risk_warning: str = ""           # Any risk concerns
    timeframe_context: str = ""      # Multi-TF summary
    trade_idea: str = ""             # AI's suggested approach (advisory only)
    raw_response: str = ""           # Full Gemini response for debugging

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "timestamp": self.timestamp,
            "market_regime": self.market_regime,
            "bias": self.bias,
            "confidence": self.confidence,
            "key_levels": self.key_levels,
            "narrative": self.narrative,
            "strategy_notes": self.strategy_notes,
            "risk_warning": self.risk_warning,
            "timeframe_context": self.timeframe_context,
            "trade_idea": self.trade_idea,
        }


@dataclass
class AISignalReview:
    """AI review of a signal generated by the rule-based engine."""
    symbol: str = ""
    signal_direction: str = ""
    signal_type: str = ""
    ai_agrees: bool = False
    agreement_score: float = 0.0     # -1 (strongly disagree) to +1 (strongly agree)
    reasoning: str = ""
    concerns: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "signal_direction": self.signal_direction,
            "signal_type": self.signal_type,
            "ai_agrees": self.ai_agrees,
            "agreement_score": self.agreement_score,
            "reasoning": self.reasoning,
            "concerns": self.concerns,
        }


@dataclass
class AITradeSignal:
    """A trade signal generated by Gemini AI."""
    symbol: str = ""
    action: str = ""                 # BUY, SELL, PASS
    confidence: float = 0.0
    entry_price: float = 0.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    reasoning: str = ""
    risk_pips: float = 0.0
    reward_pips: float = 0.0
    timestamp: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "action": self.action,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "reasoning": self.reasoning,
            "risk_pips": self.risk_pips,
            "reward_pips": self.reward_pips,
            "timestamp": self.timestamp,
        }


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  PROMPTS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SYSTEM_PROMPT = """You are Forexia AI â€” an elite institutional forex execution agent modeled after Dylan Shilts' Forexia methodology (forexia.net). You see the market as a pre-written story where institutions manipulate retail traders through predictable liquidity engineering cycles. Your job is to read the script, not react to the noise.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CORE PHILOSOPHY: THE MARKET IS A STORY, NOT A CHART
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The forex market is a 5-Act weekly play written by central banks and prime brokers. Price does NOT move randomly â€” it follows a repeating narrative structure designed to harvest retail liquidity before delivering the real move. Every candle, every session, every day of the week has a role in this script. Your edge is reading the story AHEAD of retail.

ABSOLUTE PROHIBITIONS:
- NEVER mention or use Fair Value Gaps (FVGs) â€” this is a retail ICT concept that does NOT exist in Forexia methodology
- NEVER use retail indicators (RSI, MACD, Bollinger Bands, Fibonacci retracements)
- NEVER think in terms of "support holding" or "resistance breaking" â€” these are manipulation templates, NOT real levels
- NEVER chase breakouts â€” breakouts are inductions designed to trap retail
- NEVER use the phrase "Smart Money Concepts" or "ICT" â€” Forexia is its own methodology

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 1: HEGELIAN DIALECTIC (Daily Cycle)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Every trading day follows a 3-phase manipulation cycle:

â€¢ PROBLEM (Asian Session â€” 00:00-08:00 UTC): The "connector piece" â€” a 10-hour consolidation box that builds the range. This is where institutions BUILD the trap. The Asian high and low become the bait. Most retail traders ignore this session â€” that is the point. The Asian range high/low are the liquidity targets for London.

â€¢ REACTION (London Session â€” 08:00-13:00 UTC): The "induction" â€” London breaks ONE side of the Asian range to hunt stops. This looks like a breakout to retail traders who chase it. This is the FALSE MOVE. London creates the obvious trend that retail commits to. The breakout of the Asian high or low is specifically designed to trigger retail entries and stop losses.

â€¢ SOLUTION (New York Session â€” 13:00-21:00 UTC): The "reversal" â€” New York reverses the London induction move. This is where the REAL trade happens. After London has harvested stops and committed retail to the wrong side, NY delivers the actual institutional move in the opposite direction.

KEY RULE: If London breaks above the Asian high â†’ expect NY to reverse down. If London breaks below the Asian low â†’ expect NY to reverse up. The Asian range is the thesis, London is the antithesis, NY is the synthesis.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 2: WEEKLY 5-ACT STRUCTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The week is a 5-Act play where each day has a specific narrative function:

â€¢ ACT 1 â€” SUNDAY/MONDAY (Connector/Induction): Sets the weekly range. Sunday gap + Monday price action establish the "obvious" weekly direction. This is the SMT Induction Trend â€” the direction Mon/Tue appears to be trending is almost always FALSE. NO TRADING on Sunday or Monday. These days exist only to set the trap.

â€¢ ACT 2 â€” TUESDAY (Accumulation/First Reversal): Tuesday often reverses off the highs or lows established by Sunday/Monday. This is the "Tuesday Reversal" â€” price sweeps the Mon high/low, traps breakout traders, then reverses. This is the FIRST potential trade day of the week. The setup: Mon establishes a direction â†’ Tue sweeps the Mon high or low â†’ reversal back into range.

â€¢ ACT 3 â€” WEDNESDAY (Midweek Reversal / WTF Pattern Start): The CLIMAX of the weekly story. Wednesday often delivers the midweek reversal â€” the biggest move of the week. If Sun-Mon-Tue was bullish (induction), Wednesday reverses bearish. The WTF pattern = Wednesday reversal continues through Thursday and Friday.

â€¢ ACT 4 â€” THURSDAY (Distribution/Continuation): Thursday continues Wednesday's reversal move. This is the distribution phase where the real institutional profit is extracted. Second-best trading day after Wednesday.

â€¢ ACT 5 â€” FRIDAY (Epilogue/Connector): Wind-down. Take profits, reduce risk. Friday becomes the "connector piece" linking this week's ending to next week's opening. NO NEW TRADES on Friday â€” only manage existing positions.

SMT INDUCTION TREND: The Sunday-Monday-Tuesday trend is a 3-day trap. When price trends for 3 consecutive days, retail sees it as "obvious" â€” that is precisely when the reversal comes (Wednesday).

WTF REVERSAL (Wednesday-Thursday-Friday): The real move of the week happens Wedâ†’Thuâ†’Fri, OPPOSITE to the Sunâ†’Monâ†’Tue induction direction.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 3: THE SIGNATURE TRADE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The highest-probability setup in Forexia methodology:

SIMPLE SIGNATURE TRADE (4 phases):
1. WEDGE/TRIANGLE: Price compresses into a narrowing pattern (ascending/descending/symmetric wedge or triangle). This builds potential energy and concentrates stop losses on both sides.
2. FALSE BREAKOUT: Price breaks the wedge boundary â€” retail enters. This is the INDUCTION. Breakout traders go long above the wedge top or short below the wedge bottom.
3. STOP HUNT: Price pushes slightly beyond the breakout to sweep stops of traders on the OTHER side of the wedge. Liquidity is harvested.
4. REVERSAL: The actual institutional move begins â€” price reverses through the entire wedge and continues. This is the SOLUTION. Entry here gives near-zero drawdown because you enter at the extreme after the stop hunt.

COMPLEX SIGNATURE TRADE (double induction):
Same as simple, but with TWO false breakouts â€” one above AND one below the wedge â€” before the real reversal. This traps traders in both directions before the move.

ENTRY RULES FOR SIGNATURE TRADE:
- Wait for the stop hunt (phase 3) to complete â€” NEVER enter during the breakout
- Enter on the first candle that shows rejection after the stop hunt (railroad tracks, star pattern, or strong body reversal)
- Stop loss goes behind the stop hunt extreme (the farthest point of the false breakout)
- Target: At minimum, the other side of the wedge. Extended target: the full ADR projection.
- Best timeframe: 15-minute chart for pattern, 1-minute for entry timing

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 4: PSYCHOLOGICAL LEVELS & ADR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PSYCHOLOGICAL LEVELS (Round Numbers):
- Major psych levels: .000, .500 (e.g., 1.10000, 1.10500)
- Minor psych levels: .200, .800 (e.g., 1.10200, 1.10800)
- These are where RETAIL clusters orders (stop losses and take profits). Institutions know this and engineer moves TO these levels to harvest that liquidity.
- When price approaches a psychological level, expect a reaction â€” either a bounce (liquidity grab) or a sweep through it to hunt stops.
- Psych levels are NOT support/resistance â€” they are MANIPULATION TARGETS.

AVERAGE DAILY RANGE (ADR):
- Calculate the average range (high - low) of the last 5-14 trading days
- If price has already moved 80-100% of ADR during London, the London move is EXHAUSTED
- ADR exhaustion during London = HIGH probability NY reversal
- Use ADR to project reversal targets: if London moved 60 pips up and ADR is 80, expect NY to push the remaining 20 pips up (final sweep) then reverse down
- ADR is the "budget" for the day â€” once spent, reverse is likely

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 5: CANDLESTICK ANATOMY (Forexia Style)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Forexia does NOT use retail candlestick names (engulfing, hammer, doji, etc.). Instead:

â€¢ RAILROAD TRACKS: Two consecutive candles of equal size but opposite direction. First candle is the induction, second candle is the reversal. The bigger the bodies, the stronger the signal. These appear at session transitions (Asianâ†’London, Londonâ†’NY).

â€¢ STAR PATTERNS: A small-bodied candle (star) between two larger candles. The star represents indecision at a key level â€” the market pausing before the reversal. Morning star = bullish reversal. Evening star = bearish reversal.

â€¢ WICK ANALYSIS: Long wicks = liquidity was grabbed and rejected. A long upper wick means price tried to go higher, hunted stops, and was rejected. A long lower wick means price tried to go lower, hunted stops, and was rejected. The wick IS the stop hunt.

â€¢ GOD CANDLE: An abnormally large candle (body > 3x average) caused by a news event or institutional aggression. After a God Candle, expect exhaustion and retracement. NEVER chase a God Candle â€” wait for the retracement.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 6: FRACTAL PAIRS & CORRELATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â€¢ POSITIVE CORRELATION PAIRS: EURUSD/GBPUSD move together. If EURUSD breaks a level but GBPUSD doesn't confirm â†’ the move is fake (the induction). Use non-confirmation as a signal that the breakout will fail.

â€¢ NEGATIVE CORRELATION: EURUSD vs USDCHF move opposite. If both are doing the same thing â†’ something is wrong â†’ expect reversal.

â€¢ JPY CONFIRMATION: USDJPY, EURJPY, GBPJPY â€” if all JPY pairs move the same way simultaneously, the JPY move is real. If one diverges, it's an induction on the divergent pair.

â€¢ FRACTAL PRINCIPLE: What happens on the 1-minute chart is a micro version of what happens on the daily chart. A signature trade on M1 looks identical to a signature trade on D1 â€” just different timeframes. Zoom in to find entries, zoom out to find direction.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 7: FOREXFACTORY NEWS INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â€¢ ONLY care about HIGH IMPACT (Red Folder) events
â€¢ The actual numbers DO NOT MATTER â€” "CPI came in at 3.2% vs 3.1% expected" is IRRELEVANT
â€¢ What matters: the Currency affected, the Time of release, and the Impact level
â€¢ News events are PRE-ENGINEERED CRISIS POINTS â€” they are the "plot twists" in the weekly story
â€¢ Institutions already know the number before release â€” the spike is designed to hunt stops in both directions before the real move
â€¢ Strategy: Identify the news time â†’ stay flat 15 min before â†’ watch the spike â†’ identify which side got hunted â†’ enter the opposite direction after the dust settles (God Candle exhaustion reversal)
â€¢ Tuesday/Wednesday red folder events are the most powerful catalysts because they align with the weekly reversal structure

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PILLAR 8: M & W FORMATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â€¢ M FORMATION (Double Top): Two pushes to approximately the same high. First push is London, second push is NY (or first push Mon/Tue, second push Wed). The "M" completes when price breaks the neckline (the low between the two tops). This IS the Hegelian Dialectic in pattern form â€” Problem (first high) â†’ Reaction (pullback) â†’ Solution (second high rejected â†’ reversal down).

â€¢ W FORMATION (Double Bottom): Mirror of M. Two pushes to the same low. First push hunts sell-side liquidity, second push confirms the bottom, then reversal up.

â€¢ BEST M/W SETUP: First leg forms during London, second leg forms during NY. The second leg sweeps the first leg's high/low by a few pips (stop hunt), then reverses. This is the signature trade embedded in an M/W pattern.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
OUTPUT FORMAT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You respond ONLY in valid JSON. No markdown, no code blocks, no extra text.
Keep narratives concise (2-3 sentences max per field).
Be specific â€” name exact price levels, candle patterns, and session timing.
Always frame analysis through the Forexia institutional manipulation lens.
Reference which Act of the weekly play we are in and which phase of the Hegelian Dialectic is active.
Identify inductions (false moves) vs solutions (real moves).
Note psychological levels and ADR exhaustion when relevant."""

ANALYSIS_PROMPT = """Analyze {symbol} for institutional trading opportunities using MULTI-TIMEFRAME Forexia methodology.

Current Market Data:
- Time: {time_utc} UTC ({session_phase})
- Weekly Act: {weekly_act}
- Current Price: {current_price}
- Today's Range: High {day_high}, Low {day_low}
- Spread: {spread} pips

â•â•â• MULTI-TIMEFRAME PRICE ACTION â•â•â•

ðŸ“Š M1 (Execution Timeframe â€” last {candle_count} candles):
{candle_summary}

ðŸ“Š M15 (Intraday Structure â€” last {m15_count} candles):
{m15_summary}

ðŸ“Š H1 (Session Bias â€” last {h1_count} candles):
{h1_summary}

â•â•â• COMPUTED MARKET STRUCTURE â•â•â•
{market_structure}

â•â•â• MULTI-TIMEFRAME ALIGNMENT â•â•â•
{tf_alignment}

Open Positions on {symbol}: {open_positions}

Account State: Balance ${balance}, Equity ${equity}, Open Trades: {open_trades}

FOREXIA ANALYSIS RULES:
1. Identify the HEGELIAN PHASE: Is this the Problem (Asian range), Reaction (London induction), or Solution (NY reversal)?
2. Identify the WEEKLY ACT: Are we in the induction phase (Mon/Tue) or the reversal phase (Wed/Thu)?
3. H1 shows the SESSION STORY â€” which way did London push? That is likely the induction direction
4. M15 confirms the STRUCTURE â€” look for wedges, M/W formations, and stop hunt sweeps
5. M1 is for EXECUTION TIMING only â€” railroad tracks, star patterns, wick rejections
6. Check PSYCHOLOGICAL LEVELS â€” is price near a .000 or .500 level? Expect manipulation there
7. Check ADR EXHAUSTION â€” has today's range already consumed 80%+ of ADR? Expect reversal
8. If price is near a LIQUIDITY POOL (equal highs/lows, clustered stops), expect a hunt before the real move
9. Identify any SIGNATURE TRADE setup: wedge â†’ false breakout â†’ stop hunt â†’ reversal entry
10. Check FRACTAL PAIR CORRELATION â€” if correlated pairs aren't confirming the move, it's an induction

Respond in this exact JSON format:
{{
  "market_regime": "trending_up|trending_down|ranging|volatile|calm",
  "bias": "bullish|bearish|neutral",
  "confidence": 0.0 to 1.0,
  "key_levels": [price1, price2, price3],
  "narrative": "2-3 sentence analysis using Hegelian Dialectic lens â€” identify which phase we are in, what the induction is, and where the solution will be",
  "strategy_notes": "Describe the institutional manipulation narrative â€” what trap is being set, where are stops being hunted, where is the real move going",
  "risk_warning": "Any concerns: wrong weekly act, ADR exhaustion, no clear induction yet, God Candle risk (empty string if none)",
  "timeframe_context": "Describe how H1 session bias, M15 structure, and M1 entry timing align or conflict",
  "trade_idea": "Specific Forexia setup: identify the signature trade phase, entry zone after stop hunt, SL behind the hunt extreme, TP at next psych level or ADR projection"
}}"""

SIGNAL_REVIEW_PROMPT = """Review this trading signal generated by the Forexia rule-based engine:

Signal Details:
- Symbol: {symbol}
- Direction: {direction}
- Type: {signal_type}
- Confidence: {confidence:.0%}
- Entry: {entry_price}
- Stop Loss: {stop_loss}
- Take Profit: {take_profit}
- Lot Size: {lot_size}

Market Context:
- Session: {session_phase}
- Weekly Act: {weekly_act}
- Recent candles: {candle_mini}

Do you agree with this trade? Respond in this exact JSON format:
{{
  "ai_agrees": true or false,
  "agreement_score": -1.0 to +1.0,
  "reasoning": "Why you agree/disagree (2-3 sentences)",
  "concerns": "Specific risks or reasons to be cautious (empty string if none)"
}}"""

MARKET_OVERVIEW_PROMPT = """Provide a brief multi-pair market overview for institutional forex trading.

Pairs monitored: {pairs}
Current time: {time_utc} UTC ({session_phase})
Weekly Act: {weekly_act}

For each pair, the latest price and daily range:
{pairs_data}

Account: Balance ${balance}, Equity ${equity}, {open_count} open trades

Provide a concise market overview. Respond in this exact JSON format:
{{
  "market_mood": "risk_on|risk_off|mixed|uncertain",
  "dollar_bias": "strong|weak|neutral",
  "best_opportunities": ["SYMBOL1", "SYMBOL2"],
  "avoid_pairs": ["SYMBOL3"],
  "overview": "3-4 sentence institutional market summary",
  "session_outlook": "What to expect in the current/upcoming session"
}}"""

AI_TRADE_SIGNAL_PROMPT = """You are Forexia AI â€” an institutional forex execution agent using Dylan Shilts' Forexia methodology with MULTI-TIMEFRAME ANALYSIS. Based on the data below, decide whether to EXECUTE A TRADE or PASS.

Your job is to identify and execute Forexia setups. Be decisive â€” when the weekly story and Hegelian phase align with a signature trade, TAKE IT.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FOREXIA EXECUTION FRAMEWORK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HEGELIAN DIALECTIC PHASE CHECK:
- PROBLEM (Asian 00-08 UTC): NO TRADES. Only observe the range being built. Note Asian high/low.
- REACTION (London 08-13 UTC): WATCH the induction. London will break one side of Asian range. Do NOT chase.
- SOLUTION (NY 13-21 UTC): THIS is when you trade. After London induction is confirmed, enter the reversal.
- Best entries: NY session (13-17 UTC) after London has clearly committed to one direction.

WEEKLY ACT PERMISSIONS:
- ACT 1 (Sun/Mon): NEVER trade. Observe the induction direction being set.
- ACT 2 (Tuesday): Trade the Tuesday Reversal â€” price sweeps Mon high/low then reverses.
- ACT 3 (Wednesday): BEST DAY. Midweek reversal. Trade against the Sun-Mon-Tue induction trend.
- ACT 4 (Thursday): Continue Wednesday's move. Distribution phase â€” second best day.
- ACT 5 (Friday): CLOSE/manage only. No new entries.

SIGNATURE TRADE IDENTIFICATION:
1. Look for a WEDGE or TRIANGLE on M15 (narrowing price compression)
2. Wait for the FALSE BREAKOUT of the wedge boundary (this is the induction)
3. Wait for the STOP HUNT â€” price pushes beyond the breakout to sweep stops
4. ENTER on the REVERSAL candle after the stop hunt (railroad tracks, star, or strong rejection wick)
5. SL goes behind the stop hunt extreme | TP at opposite side of wedge + ADR projection

M/W FORMATION CHECK:
- If price is making a second push to a previous high (M top) or low (W bottom):
  - First leg = London, Second leg = NY â†’ classic setup
  - Second leg sweeps first leg by 5-15 pips (stop hunt) then reverses
  - Enter after the second leg rejection, SL behind the sweep, TP at neckline minimum

ADR EXHAUSTION CHECK:
- If today's range has consumed 80%+ of the Average Daily Range â†’ reversal is imminent
- If London moved the full ADR â†’ NY MUST reverse (budget is spent)
- Use ADR to set targets: remaining ADR = remaining move potential

PSYCHOLOGICAL LEVEL CONFLUENCE:
- If entry coincides with a .000 or .500 level â†’ add +10% confidence
- If SL is behind a psychological level â†’ stronger because retail clusters stops there
- Psych levels are where retail places orders â†’ institutions target them for liquidity

CRITICAL DIRECTIONAL BIAS:
- SELL trades historically outperform BUY trades on this system
- Be MORE SELECTIVE with BUY signals â€” only take BUY when Hegelian Solution is clearly bullish
- For BUY: require strong rejection at a low + session reversal confirmation + weekly act alignment
- For SELL: trend continuation (Wed/Thu selling after Mon/Tue buying) and clear induction reversal

PAIR-SPECIFIC RULES (PERFORMANCE-BASED):
â˜… STAR PAIRS (proven profitable â€” trade aggressively):
  - GBPJPY: +$1,152 profit, 60% win rate â€” OUR BEST PAIR. JPY volatility plays.
  - USDJPY: +$736 profit, 59% win rate â€” MOST CONSISTENT. High volume.
  - EURJPY: +$171 profit, 56% win rate â€” SOLID. JPY strength plays.
  â†’ For star pairs: trade with conviction, can accept slightly lower confidence.

âš ï¸ NEUTRAL PAIRS (trade selectively):
  - GBPUSD: 60% win rate but low profit â€” only HIGH conviction setups.
  - EURUSD: 43% win rate â€” REQUIRE perfect multi-TF + weekly act + Hegelian alignment.
  - USDCHF, EURAUD, EURGBP, GBPAUD: Low volume, trade only A+ signature trade setups.

ðŸš« BANNED PAIRS (NEVER signal):
  - AUDNZD, XAUUSD, NZDUSD, CADJPY, USDCAD, EURCHF, GBPNZD, CHFJPY, NZDJPY, NZDCHF
  â†’ If analyzing any banned pair, ALWAYS return action="NO_TRADE" with confidence 0.0

EURUSD SPECIAL RULE:
- 43% win rate â€” below threshold. Only trade when:
  1. ALL three timeframes perfectly aligned
  2. Clear signature trade pattern or M/W formation
  3. NY Killzone (13-16 UTC) + Hegelian Solution phase
  4. Confidence â‰¥ 0.75

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXECUTION RULES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. Trade when confidence >= 0.60 â€” you need edge, not perfection
2. Set stop-loss behind the nearest stop hunt extreme or liquidity sweep level
3. Target at least 2:1 reward-to-risk (3:1 or 4:1 preferred)
4. NEVER trade against the Hegelian phase â€” if we are in the Reaction, do NOT enter the Solution yet
5. Risk max 2% of account per trade
6. SL and TP WILL be executed â€” set them at REAL structural levels

MULTI-TIMEFRAME DECISION MATRIX:
- H1 shows session direction (London induction) â†’ IDENTIFY what is being induced
- M15 shows structure (wedge, M/W, stop hunt level) â†’ CONFIRM the setup
- M1 shows entry timing (reversal candle, railroad tracks, wick rejection) â†’ ENTER
- All TFs must tell the same STORY â€” if conflicting, PASS

MARKET STRUCTURE SCORING:
- Price at order block + psychological level = premium entry (+10% confidence)
- Price just completed a stop hunt (wick beyond swing, then rejection) = PRIME entry
- Price near equal highs/lows (liquidity pool) = watch for hunt first, then enter after sweep
- Strong trend on H1 (HH/HL or LH/LL) = trade the Hegelian phase WITH the solution direction

â•â•â• MARKET DATA â•â•â•
Symbol: {symbol}
Time: {time_utc} UTC ({session_phase})
Weekly Act: {weekly_act}
Current Price: {current_price} | Bid: {bid} | Ask: {ask}
Today's Range: High {day_high}, Low {day_low}
Spread: {spread} pips
Account: Balance ${balance}, Equity ${equity}
Open Trades: {open_trades}
Existing position on {symbol}: {existing_position}

â•â•â• MULTI-TIMEFRAME PRICE ACTION â•â•â•

ðŸ“Š M1 (last {candle_count} candles):
{candle_summary}

ðŸ“Š M15 Structure:
{m15_summary}

ðŸ“Š H1 Structure:
{h1_summary}

â•â•â• COMPUTED MARKET STRUCTURE â•â•â•
{market_structure}

â•â•â• TF ALIGNMENT â•â•â•
{tf_alignment}

â•â•â• AI ANALYSIS (from analyze_pair) â•â•â•
Regime: {ai_regime} | Bias: {ai_bias} | Confidence: {ai_confidence}
Narrative: {ai_narrative}
Key Levels: {ai_key_levels}

â•â•â• RISK MANAGEMENT RULES (MANDATORY) â•â•â•
- Stop Loss: MUST be EXACTLY 20 pips from entry (50 pips for XAUUSD/Gold)
- Take Profit: MUST be between 70-100 pips from entry (80 pips ideal, 125 for Gold)
- For JPY pairs: 1 pip = 0.01 (so 20 pips SL = 0.20 price distance)
- For standard pairs: 1 pip = 0.0001 (so 20 pips SL = 0.0020 price distance)
- For XAUUSD: 1 pip = 0.01 (so 50 pips SL = 0.50 price distance)
- NEVER place SL tighter than 20 pips or TP shorter than 70 pips

Respond in this EXACT JSON format:
{{
  "action": "BUY" or "SELL" or "PASS",
  "confidence": 0.0 to 1.0,
  "entry_price": current market price for immediate execution,
  "stop_loss": price EXACTLY 20 pips behind entry (50 for Gold),
  "take_profit": price 70-100 pips ahead of entry (125 for Gold),
  "reasoning": "1-2 sentence Forexia reasoning: name the Hegelian phase, weekly act, signature trade phase, and key induction/solution logic",
  "risk_pips": 20 (or 50 for Gold),
  "reward_pips": 70-100 (or 125 for Gold)
}}"""


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  GEMINI AI ADVISOR ENGINE
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class GeminiAdvisor:
    """
    Google Gemini-powered market intelligence and trade execution agent.
    
    Connects to the Gemini API to provide:
      - Per-pair market analysis
      - Signal validation/review  
      - Market overview across all pairs
      - AI-generated trade signals (executes via orchestrator)
      - Real-time commentary for the dashboard
    """

    # Gemini API endpoint
    API_URL = "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    DEFAULT_MODEL = "gemini-2.5-pro"

    # Model fallback chain: try best model first, then fall back to faster/cheaper ones
    # gemini-2.5-pro: Best reasoning & analysis (ideal for multi-TF trade decisions)
    # gemini-2.5-flash: Fast & efficient (good backup when pro is rate-limited)
    # gemini-2.0-flash: Lightweight backup with high free-tier quota
    FALLBACK_MODELS = [
        "gemini-2.5-pro",         # BEST: Superior reasoning for trade analysis
        "gemini-2.5-flash",       # FAST: Good balance of speed & quality
        "gemini-2.0-flash",       # BACKUP: High free-tier quota
        "gemini-2.0-flash-lite",  # EMERGENCY: Maximum availability
    ]

    # Models that DON'T support systemInstruction or responseMimeType: "application/json"
    BASIC_MODELS = {"gemma-3-27b-it", "gemma-3-12b-it", "gemma-3-4b-it", "gemma-3-1b-it"}

    def __init__(self):
        self._api_key: str = ""
        self._model: str = self.DEFAULT_MODEL
        self._enabled: bool = False
        self._client: Optional[httpx.AsyncClient] = None

        # Market Structure Analyzer (pure computation, no AI)
        self._structure_analyzer = MarketStructureAnalyzer()

        # Multi-timeframe candle cache: symbol â†’ {tf: candles}
        self._mtf_cache: Dict[str, Dict[str, List]] = {}

        # Cache to avoid spamming API
        self._analysis_cache: Dict[str, AIAnalysis] = {}   # symbol â†’ latest analysis
        self._overview_cache: Optional[Dict] = None
        self._last_overview_time: float = 0
        self._signal_reviews: List[AISignalReview] = []     # recent signal reviews
        self._ai_trade_signals: List[AITradeSignal] = []    # recent AI trade signals

        # Rate limiting
        self._last_call_time: float = 0
        self._min_call_interval: float = 2.0  # Min 2 seconds between calls
        self._daily_calls: int = 0
        self._daily_limit: int = 1400         # Gemini free tier = 1500/day, keep buffer
        self._daily_reset_date: str = ""      # Track which UTC date the counter belongs to

        # Track which models are temporarily exhausted (model â†’ retry_after_time)
        self._model_exhausted: Dict[str, float] = {}

        # Background scan
        self._scan_task: Optional[asyncio.Task] = None
        self._scan_interval: int = 150        # Scan all pairs every 2.5 minutes (M1 timeframe)

        logger.info("Gemini AI Advisor initialized (disabled until API key configured)")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  CONFIGURATION
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def configure(self, api_key: str, model: str = ""):
        """Set the Gemini API key and optionally the model."""
        self._api_key = api_key.strip()
        if model:
            self._model = model.strip()
        self._enabled = bool(self._api_key)
        if self._enabled:
            logger.info(f"Gemini AI Advisor: ENABLED (model: {self._model})")
        else:
            logger.info("Gemini AI Advisor: DISABLED (no API key)")

    @property
    def is_enabled(self) -> bool:
        return self._enabled and bool(self._api_key)

    @property
    def status(self) -> Dict[str, Any]:
        now = time.time()
        exhausted_models = [m for m, t in self._model_exhausted.items() if now < t]
        return {
            "enabled": self.is_enabled,
            "model": self._model,
            "daily_calls": self._daily_calls,
            "daily_limit": self._daily_limit,
            "cached_analyses": len(self._analysis_cache),
            "signal_reviews": len(self._signal_reviews),
            "ai_trades_generated": len(self._ai_trade_signals),
            "exhausted_models": exhausted_models,
            "fallback_chain": self.FALLBACK_MODELS,
        }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  GEMINI API COMMUNICATION
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _call_gemini(self, prompt: str, system: str = SYSTEM_PROMPT) -> Optional[str]:
        """
        Send a prompt to Gemini and return the text response.
        Implements model fallback chain: tries configured model first,
        then falls back through alternate models when rate-limited (429).
        Handles rate limiting, error handling, and daily quota.
        """
        if not self.is_enabled:
            return None

        # Rate limiting
        now = time.time()
        elapsed = now - self._last_call_time
        if elapsed < self._min_call_interval:
            await asyncio.sleep(self._min_call_interval - elapsed)

        # Daily quota check â€” reset counter when UTC date changes
        today_utc = datetime.now(timezone.utc).strftime("%Y-%m-%d")
        if today_utc != self._daily_reset_date:
            if self._daily_calls > 0:
                logger.info(f"Gemini daily counter reset (new day: {today_utc}, prev calls: {self._daily_calls})")
            self._daily_calls = 0
            self._daily_reset_date = today_utc

        if self._daily_calls >= self._daily_limit:
            logger.warning("Gemini daily API limit reached â€” skipping call")
            return None

        # Build fallback chain: primary model first, then fallbacks
        models_to_try = [self._model]
        for m in self.FALLBACK_MODELS:
            if m != self._model and m not in models_to_try:
                models_to_try.append(m)

        if not self._client:
            self._client = httpx.AsyncClient(timeout=60)

        for model in models_to_try:
            # Skip models that are known to be exhausted (with retry-after)
            exhausted_until = self._model_exhausted.get(model, 0)
            if time.time() < exhausted_until:
                continue

            is_basic = model in self.BASIC_MODELS
            url = self.API_URL.format(model=model)

            # Build payload â€” basic models don't support systemInstruction or JSON mode
            if is_basic:
                # Prepend system prompt into the user prompt for basic models
                combined_prompt = f"{system}\n\n---\n\nIMPORTANT: Return ONLY valid JSON. No markdown, no code blocks, no explanation.\n\n{prompt}"
                payload = {
                    "contents": [{"parts": [{"text": combined_prompt}]}],
                    "generationConfig": {
                        "temperature": 0.3,
                        "topP": 0.8,
                        "topK": 40,
                        "maxOutputTokens": 8192,
                    },
                }
            else:
                payload = {
                    "contents": [{"parts": [{"text": prompt}]}],
                    "systemInstruction": {"parts": [{"text": system}]},
                    "generationConfig": {
                        "temperature": 0.3,
                        "topP": 0.8,
                        "topK": 40,
                        "maxOutputTokens": 8192,
                        "responseMimeType": "application/json",
                        "thinkingConfig": {"thinkingBudget": 0},
                    },
                }

            try:
                resp = await self._client.post(
                    f"{url}?key={self._api_key}",
                    json=payload,
                )
                self._last_call_time = time.time()
                self._daily_calls += 1

                if resp.status_code == 200:
                    data = resp.json()
                    candidates = data.get("candidates", [])
                    if candidates:
                        parts = candidates[0].get("content", {}).get("parts", [])
                        if parts:
                            result = parts[0].get("text", "")
                            if model != self._model:
                                logger.info(f"Gemini fallback succeeded with model: {model}")
                            return result
                    logger.warning(f"Gemini ({model}) returned empty response")
                    continue

                elif resp.status_code == 429:
                    # Extract retry delay from response if available
                    retry_delay = 60  # Default 60s backoff
                    try:
                        err_data = resp.json()
                        details = err_data.get("error", {}).get("details", [])
                        for d in details:
                            if d.get("@type", "").endswith("RetryInfo"):
                                delay_str = d.get("retryDelay", "60s")
                                retry_delay = int(float(delay_str.rstrip("s")))
                                break
                    except Exception:
                        pass

                    self._model_exhausted[model] = time.time() + retry_delay
                    logger.warning(f"Gemini ({model}) rate limited (429) â€” blocked for {retry_delay}s, trying next model...")
                    continue

                else:
                    logger.error(f"Gemini ({model}) API error {resp.status_code}: {resp.text[:200]}")
                    continue

            except httpx.TimeoutException:
                logger.warning(f"Gemini ({model}) API timeout â€” trying next model...")
                continue
            except Exception as e:
                logger.error(f"Gemini ({model}) API call failed: {e}")
                continue

        # All models exhausted
        logger.warning("All Gemini/Gemma models exhausted â€” no AI response available")
        return None

    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """Parse JSON from Gemini response, handling common issues."""
        if not text:
            return None
        try:
            # Clean potential markdown wrapping
            cleaned = text.strip()
            if cleaned.startswith("```"):
                lines = cleaned.split("\n")
                cleaned = "\n".join(lines[1:-1]) if len(lines) > 2 else cleaned
            return json.loads(cleaned)
        except json.JSONDecodeError as e:
            # Try to extract JSON object from mixed text
            try:
                start = text.index("{")
                end = text.rindex("}") + 1
                return json.loads(text[start:end])
            except (ValueError, json.JSONDecodeError):
                pass
            logger.warning(f"Failed to parse Gemini JSON: {e}")
            logger.warning(f"Raw response (first 500 chars): {text[:500]}")
            return None

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  MULTI-TIMEFRAME & MARKET STRUCTURE HELPERS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def _fetch_multi_tf_candles(self, symbol: str, bridge) -> Dict[str, List]:
        """Fetch M1, M15, and H1 candles for a symbol."""
        result = {"M1": [], "M15": [], "H1": []}
        try:
            # Fetch all timeframes (M1 already fetched in scan loop, so pass it in)
            for tf, count in [("M15", 50), ("H1", 24)]:
                try:
                    candles = await bridge.get_candles(symbol, tf, count)
                    result[tf] = candles or []
                except Exception as e:
                    logger.warning(f"Failed to fetch {tf} candles for {symbol}: {e}")
        except Exception as e:
            logger.warning(f"Multi-TF fetch error for {symbol}: {e}")
        self._mtf_cache[symbol] = result
        return result

    def _build_candle_summary(self, candles: List[Any], count: int = 20) -> str:
        """Build compressed candle summary string."""
        if not candles:
            return "No data available"
        recent = candles[-count:] if len(candles) >= count else candles
        lines = []
        for c in recent:
            ts = c.timestamp.strftime("%H:%M") if hasattr(c, "timestamp") else ""
            o = getattr(c, "open", 0)
            h = getattr(c, "high", 0)
            l = getattr(c, "low", 0)
            cl = getattr(c, "close", 0)
            body = "â–²" if cl > o else "â–¼" if cl < o else "â”€"
            lines.append(f"  {ts} O:{o:.5f} H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")
        return "\n".join(lines)

    def _build_tf_alignment(self, symbol: str, m1_candles: List, m15_candles: List, h1_candles: List) -> str:
        """Compute multi-timeframe alignment score and summary."""
        def _get_bias(candles: List, lookback: int = 5) -> str:
            if not candles or len(candles) < lookback:
                return "unknown"
            recent = candles[-lookback:]
            first_close = getattr(recent[0], "close", 0)
            last_close = getattr(recent[-1], "close", 0)
            if last_close > first_close:
                return "bullish"
            elif last_close < first_close:
                return "bearish"
            return "neutral"

        m1_bias = _get_bias(m1_candles, 10)
        m15_bias = _get_bias(m15_candles, 5)
        h1_bias = _get_bias(h1_candles, 4)

        # Count alignment
        biases = [m1_bias, m15_bias, h1_bias]
        bullish_count = biases.count("bullish")
        bearish_count = biases.count("bearish")

        if bullish_count == 3:
            alignment = "STRONG BULLISH ALIGNMENT (all TFs bullish)"
            score = "+3"
        elif bearish_count == 3:
            alignment = "STRONG BEARISH ALIGNMENT (all TFs bearish)"
            score = "-3"
        elif bullish_count == 2:
            alignment = f"MODERATE BULLISH (2/3 TFs bullish, {[tf for tf, b in zip(['M1','M15','H1'], biases) if b != 'bullish'][0]} diverging)"
            score = "+2"
        elif bearish_count == 2:
            alignment = f"MODERATE BEARISH (2/3 TFs bearish, {[tf for tf, b in zip(['M1','M15','H1'], biases) if b != 'bearish'][0]} diverging)"
            score = "-2"
        else:
            alignment = "MIXED / CONFLICTING â€” exercise caution"
            score = "0"

        return f"M1: {m1_bias.upper()} | M15: {m15_bias.upper()} | H1: {h1_bias.upper()} â†’ {alignment} (Score: {score})"

    def get_structure_data(self) -> Dict[str, Dict]:
        """Get all cached market structure data for the API."""
        return self._structure_analyzer.get_all_cached()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  ANALYSIS METHODS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def analyze_pair(
        self,
        symbol: str,
        candles: List[Any],
        session_phase: str,
        weekly_act: str,
        account_balance: float = 0,
        account_equity: float = 0,
        open_positions: List[Dict] = None,
        spread: float = 0,
        m15_candles: List[Any] = None,
        h1_candles: List[Any] = None,
    ) -> Optional[AIAnalysis]:
        """
        Run a full AI analysis on a single pair using MULTI-TIMEFRAME data
        and computed market structure.
        Returns an AIAnalysis with market regime, bias, narrative, etc.
        """
        if not self.is_enabled:
            return None

        # Build M1 candle summary (last 20 candles compressed)
        candle_summary = self._build_candle_summary(candles, 20)
        recent = candles[-20:] if len(candles) >= 20 else candles

        # Build M15 summary
        m15_summary = self._build_candle_summary(m15_candles, 12) if m15_candles else "Not available"
        m15_count = min(len(m15_candles), 12) if m15_candles else 0

        # Build H1 summary
        h1_summary = self._build_candle_summary(h1_candles, 8) if h1_candles else "Not available"
        h1_count = min(len(h1_candles), 8) if h1_candles else 0

        # Run Market Structure Analysis (pure computation â€” instant)
        structure = self._structure_analyzer.analyze(symbol, candles)
        market_structure_text = structure.to_prompt_context() if structure else "Structure data unavailable"

        # Build TF alignment
        tf_alignment = self._build_tf_alignment(
            symbol, candles, m15_candles or [], h1_candles or []
        )

        # Current price
        current_price = getattr(candles[-1], "close", 0) if candles else 0
        day_high = max(getattr(c, "high", 0) for c in candles[-100:]) if candles else 0
        day_low = min(getattr(c, "low", 999) for c in candles[-100:]) if candles else 0

        # Open positions on this symbol
        sym_positions = "None"
        if open_positions:
            pos_list = [p for p in open_positions if (p.get("symbol", "").rstrip(".") == symbol)]
            if pos_list:
                sym_positions = ", ".join(
                    f"{p.get('side', '?')} {p.get('volume', 0)} @ {p.get('open_price', 0):.5f} (P/L: {p.get('profit', 0):.2f})"
                    for p in pos_list
                )

        open_count = len(open_positions) if open_positions else 0

        prompt = ANALYSIS_PROMPT.format(
            symbol=symbol,
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            current_price=f"{current_price:.5f}",
            day_high=f"{day_high:.5f}",
            day_low=f"{day_low:.5f}",
            spread=f"{spread:.1f}",
            candle_count=len(recent),
            candle_summary=candle_summary,
            m15_count=m15_count,
            m15_summary=m15_summary,
            h1_count=h1_count,
            h1_summary=h1_summary,
            market_structure=market_structure_text,
            tf_alignment=tf_alignment,
            open_positions=sym_positions,
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_trades=open_count,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        analysis = AIAnalysis(
            symbol=symbol,
            timestamp=datetime.now(timezone.utc).isoformat(),
            market_regime=parsed.get("market_regime", "unknown"),
            bias=parsed.get("bias", "neutral"),
            confidence=float(parsed.get("confidence", 0)),
            key_levels=[float(x) for x in parsed.get("key_levels", []) if x],
            narrative=parsed.get("narrative", ""),
            strategy_notes=parsed.get("strategy_notes", ""),
            risk_warning=parsed.get("risk_warning", ""),
            timeframe_context=parsed.get("timeframe_context", ""),
            trade_idea=parsed.get("trade_idea", ""),
            raw_response=raw or "",
        )

        # Cache it
        self._analysis_cache[symbol] = analysis
        logger.info(
            f"[GEMINI] {symbol} â€” Regime: {analysis.market_regime}, "
            f"Bias: {analysis.bias}, Confidence: {analysis.confidence:.0%}"
        )
        return analysis

    async def review_signal(
        self,
        symbol: str,
        direction: str,
        signal_type: str,
        confidence: float,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        lot_size: float,
        session_phase: str,
        weekly_act: str,
        candles: List[Any] = None,
    ) -> Optional[AISignalReview]:
        """
        Ask Gemini to review a signal generated by the rule engine.
        Returns agreement score and reasoning.
        """
        if not self.is_enabled:
            return None

        candle_mini = "N/A"
        if candles and len(candles) >= 5:
            last5 = candles[-5:]
            lines = []
            for c in last5:
                cl = getattr(c, "close", 0)
                h = getattr(c, "high", 0)
                l = getattr(c, "low", 0)
                body = "â–²" if cl > getattr(c, "open", 0) else "â–¼"
                lines.append(f"H:{h:.5f} L:{l:.5f} C:{cl:.5f} {body}")
            candle_mini = " | ".join(lines)

        prompt = SIGNAL_REVIEW_PROMPT.format(
            symbol=symbol,
            direction=direction,
            signal_type=signal_type,
            confidence=confidence,
            entry_price=f"{entry_price:.5f}",
            stop_loss=f"{stop_loss:.5f}",
            take_profit=f"{take_profit:.5f}",
            lot_size=lot_size,
            session_phase=session_phase,
            weekly_act=weekly_act,
            candle_mini=candle_mini,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        review = AISignalReview(
            symbol=symbol,
            signal_direction=direction,
            signal_type=signal_type,
            ai_agrees=parsed.get("ai_agrees", False),
            agreement_score=float(parsed.get("agreement_score", 0)),
            reasoning=parsed.get("reasoning", ""),
            concerns=parsed.get("concerns", ""),
        )

        # Keep last 20 reviews
        self._signal_reviews.append(review)
        if len(self._signal_reviews) > 20:
            self._signal_reviews = self._signal_reviews[-20:]

        emoji = "âœ…" if review.ai_agrees else "âš ï¸"
        logger.info(
            f"[GEMINI] Signal Review {emoji} {symbol} {direction} â€” "
            f"Score: {review.agreement_score:+.2f}, "
            f"{'AGREES' if review.ai_agrees else 'DISAGREES'}: {review.reasoning[:80]}"
        )
        return review

    async def generate_trade_signal(
        self,
        symbol: str,
        candles: List[Any],
        session_phase: str,
        weekly_act: str,
        account_balance: float = 0,
        account_equity: float = 0,
        open_positions: List[Dict] = None,
        spread: float = 0,
        bid: float = 0,
        ask: float = 0,
        m15_candles: List[Any] = None,
        h1_candles: List[Any] = None,
    ) -> Optional[AITradeSignal]:
        """
        Ask Gemini to generate an actionable trade signal using multi-TF data
        and computed market structure.
        Returns AITradeSignal with BUY/SELL/PASS decision and levels.
        """
        if not self.is_enabled:
            return None

        # Get the cached analysis for this symbol
        cached = self._analysis_cache.get(symbol)
        if not cached:
            return None

        # Only attempt trades when AI analysis confidence is reasonable
        if cached.confidence < 0.40:
            return None

        # Build M1 candle summary
        candle_summary = self._build_candle_summary(candles, 30)
        recent = candles[-30:] if len(candles) >= 30 else candles

        # Build M15 and H1 summaries
        m15_summary = self._build_candle_summary(m15_candles, 8) if m15_candles else "Not available"
        h1_summary = self._build_candle_summary(h1_candles, 6) if h1_candles else "Not available"

        # Get computed market structure
        structure = self._structure_analyzer.get_cached(symbol)
        market_structure_text = structure.to_prompt_context() if structure else "Structure data unavailable"

        # TF alignment
        tf_alignment = self._build_tf_alignment(
            symbol, candles, m15_candles or [], h1_candles or []
        )

        current_price = getattr(candles[-1], "close", 0) if candles else 0
        day_high = max(getattr(c, "high", 0) for c in candles[-100:]) if candles else 0
        day_low = min(getattr(c, "low", 999) for c in candles[-100:]) if candles else 0

        # Check existing position
        existing = "None"
        if open_positions:
            pos_list = [p for p in open_positions if (p.get("symbol", "").rstrip(".") == symbol)]
            if pos_list:
                existing = ", ".join(
                    f"{p.get('side', '?')} {p.get('volume', 0)} @ {p.get('open_price', 0):.5f}"
                    for p in pos_list
                )

        open_count = len(open_positions) if open_positions else 0

        prompt = AI_TRADE_SIGNAL_PROMPT.format(
            symbol=symbol,
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            current_price=f"{current_price:.5f}",
            bid=f"{bid:.5f}" if bid else f"{current_price:.5f}",
            ask=f"{ask:.5f}" if ask else f"{current_price:.5f}",
            day_high=f"{day_high:.5f}",
            day_low=f"{day_low:.5f}",
            spread=f"{spread:.1f}",
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_trades=open_count,
            existing_position=existing,
            candle_count=len(recent),
            candle_summary=candle_summary,
            m15_summary=m15_summary,
            h1_summary=h1_summary,
            market_structure=market_structure_text,
            tf_alignment=tf_alignment,
            ai_regime=cached.market_regime,
            ai_bias=cached.bias,
            ai_confidence=f"{cached.confidence:.0%}",
            ai_narrative=cached.narrative,
            ai_key_levels=", ".join(f"{lv:.5f}" for lv in cached.key_levels) if cached.key_levels else "None",
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if not parsed:
            return None

        action = parsed.get("action", "PASS").upper()
        if action not in ("BUY", "SELL"):
            logger.info(f"[GEMINI] {symbol} â€” AI decided to PASS (no trade)")
            return None

        signal = AITradeSignal(
            symbol=symbol,
            action=action,
            confidence=float(parsed.get("confidence", 0)),
            entry_price=float(parsed.get("entry_price", current_price)),
            stop_loss=float(parsed.get("stop_loss", 0)),
            take_profit=float(parsed.get("take_profit", 0)),
            reasoning=parsed.get("reasoning", ""),
            risk_pips=float(parsed.get("risk_pips", 0)),
            reward_pips=float(parsed.get("reward_pips", 0)),
            timestamp=datetime.now(timezone.utc).isoformat(),
        )

        # Validate: must have SL and TP
        if signal.stop_loss <= 0 or signal.take_profit <= 0:
            logger.warning(f"[GEMINI] {symbol} â€” AI signal missing SL/TP, discarding")
            return None

        # Validate: minimum confidence â€” use 0.50 as floor for AI signals
        if signal.confidence < 0.50:
            logger.info(f"[GEMINI] {symbol} â€” AI confidence too low ({signal.confidence:.0%}), skipping")
            return None

        # Store for dashboard
        self._ai_trade_signals.append(signal)
        if len(self._ai_trade_signals) > 30:
            self._ai_trade_signals = self._ai_trade_signals[-30:]

        logger.info(
            f"[GEMINI] ðŸ”¥ AI TRADE SIGNAL: {action} {symbol} @ {signal.entry_price:.5f} | "
            f"SL: {signal.stop_loss:.5f} | TP: {signal.take_profit:.5f} | "
            f"Conf: {signal.confidence:.0%} | {signal.reasoning[:80]}"
        )
        return signal

    async def market_overview(
        self,
        pairs: List[str],
        session_phase: str,
        weekly_act: str,
        pairs_data: Dict[str, Dict] = None,
        account_balance: float = 0,
        account_equity: float = 0,
        open_count: int = 0,
    ) -> Optional[Dict]:
        """
        Generate a multi-pair market overview.
        Cached for 5 minutes to avoid excessive API calls.
        """
        if not self.is_enabled:
            return None

        # Check cache (5 min)
        now = time.time()
        if self._overview_cache and (now - self._last_overview_time) < 300:
            return self._overview_cache

        # Build pairs data summary
        data_lines = []
        if pairs_data:
            for sym, d in pairs_data.items():
                price = d.get("price", 0)
                high = d.get("high", 0)
                low = d.get("low", 0)
                data_lines.append(f"  {sym}: Price={price:.5f}, DayH={high:.5f}, DayL={low:.5f}")
        pairs_str = "\n".join(data_lines) if data_lines else "Price data unavailable"

        prompt = MARKET_OVERVIEW_PROMPT.format(
            pairs=", ".join(pairs),
            time_utc=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M"),
            session_phase=session_phase,
            weekly_act=weekly_act,
            pairs_data=pairs_str,
            balance=f"{account_balance:.2f}",
            equity=f"{account_equity:.2f}",
            open_count=open_count,
        )

        raw = await self._call_gemini(prompt)
        parsed = self._parse_json_response(raw)

        if parsed:
            parsed["timestamp"] = datetime.now(timezone.utc).isoformat()
            self._overview_cache = parsed
            self._last_overview_time = now
            logger.info(
                f"[GEMINI] Market Overview â€” Mood: {parsed.get('market_mood')}, "
                f"USD: {parsed.get('dollar_bias')}, "
                f"Best: {parsed.get('best_opportunities')}"
            )

        return parsed

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  BACKGROUND SCAN LOOP
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    async def start_scan_loop(self, orchestrator):
        """Start the background AI analysis loop."""
        if self._scan_task and not self._scan_task.done():
            return
        self._scan_task = asyncio.create_task(self._scan_loop(orchestrator))
        logger.info(f"Gemini AI Scan Loop: STARTED â€” analyzing every {self._scan_interval}s")

    async def stop_scan_loop(self):
        """Stop the background AI analysis loop."""
        if self._scan_task:
            self._scan_task.cancel()
            try:
                await self._scan_task
            except asyncio.CancelledError:
                pass
            self._scan_task = None
            logger.info("Gemini AI Scan Loop: STOPPED")

    async def _scan_loop(self, orchestrator):
        """Background loop that analyzes all configured pairs with Gemini."""
        while True:
            try:
                await asyncio.sleep(self._scan_interval)

                if not self.is_enabled:
                    continue

                bridge = orchestrator.bridge
                if not bridge or not bridge.is_connected:
                    continue

                settings = orchestrator.settings
                pairs = settings.agent.pairs
                session_phase = orchestrator.dialectic.get_current_phase(
                    datetime.utcnow()
                ).value
                weekly_act = orchestrator.weekly.get_current_act(
                    datetime.utcnow()
                ).value

                account = orchestrator._account
                balance = getattr(account, "balance", 0)
                equity = getattr(account, "equity", 0)

                # Get open positions once
                open_positions = []
                try:
                    open_positions = await bridge.get_open_positions()
                except Exception:
                    pass

                # Collect price data for overview
                pairs_data = {}

                # Check which symbols already have open positions
                open_symbols = set()
                for pos in open_positions:
                    sym = (pos.get("symbol") or "").rstrip(".")
                    if sym:
                        open_symbols.add(sym)

                # Analyze each pair with MULTI-TIMEFRAME data
                # Toxic pairs list â€” never waste API calls on these
                _toxic = {"AUDNZD", "NZDUSD", "NZDCHF", "NZDJPY", "GBPNZD",
                          "CADJPY", "CHFJPY", "EURCHF", "USDCAD", "XAUUSD"}
                for symbol in pairs:
                    if symbol in _toxic:
                        continue
                    try:
                        # Fetch M1 candles (execution timeframe)
                        candles = await bridge.get_candles(symbol, "M1", 100)
                        if not candles or len(candles) < 20:
                            continue

                        # Fetch M15 and H1 candles (structure timeframes)
                        m15_candles = []
                        h1_candles = []
                        try:
                            m15_candles = await bridge.get_candles(symbol, "M15", 50) or []
                        except Exception as e:
                            logger.debug(f"M15 fetch failed for {symbol}: {e}")
                        try:
                            h1_candles = await bridge.get_candles(symbol, "H1", 24) or []
                        except Exception as e:
                            logger.debug(f"H1 fetch failed for {symbol}: {e}")

                        # Cache multi-TF candles
                        self._mtf_cache[symbol] = {"M1": candles, "M15": m15_candles, "H1": h1_candles}

                        # Get spread and price
                        spread = 0
                        bid = 0
                        ask = 0
                        try:
                            price_info = await bridge.get_current_price(symbol)
                            if price_info:
                                spread = price_info.get("spread", 0)
                                bid = price_info.get("bid", 0)
                                ask = price_info.get("ask", 0)
                                pairs_data[symbol] = {
                                    "price": bid,
                                    "high": max(getattr(c, "high", 0) for c in candles),
                                    "low": min(getattr(c, "low", 999) for c in candles),
                                }
                        except Exception:
                            pass

                        # Step 1: Analyze the pair with multi-TF data
                        analysis = await self.analyze_pair(
                            symbol=symbol,
                            candles=candles,
                            session_phase=session_phase,
                            weekly_act=weekly_act,
                            account_balance=balance,
                            account_equity=equity,
                            open_positions=open_positions,
                            spread=spread,
                            m15_candles=m15_candles,
                            h1_candles=h1_candles,
                        )

                        # Step 2: If auto_trade is ON and no existing position,
                        #          ask AI for a trade signal
                        if (settings.agent.auto_trade
                                and symbol not in open_symbols
                                and analysis
                                and analysis.confidence >= 0.40
                                and spread <= settings.risk.max_spread_pips):
                            try:
                                await asyncio.sleep(2)  # Rate limit pause
                                trade_signal = await self.generate_trade_signal(
                                    symbol=symbol,
                                    candles=candles,
                                    session_phase=session_phase,
                                    weekly_act=weekly_act,
                                    account_balance=balance,
                                    account_equity=equity,
                                    open_positions=open_positions,
                                    spread=spread,
                                    bid=bid,
                                    ask=ask,
                                    m15_candles=m15_candles,
                                    h1_candles=h1_candles,
                                )
                                if trade_signal:
                                    # Execute via orchestrator
                                    executed = await orchestrator.execute_ai_signal(trade_signal)
                                    if executed:
                                        open_symbols.add(symbol)
                            except Exception as e:
                                logger.error(f"Gemini trade signal error for {symbol}: {e}")

                        # Brief pause between pair analyses to respect rate limits
                        await asyncio.sleep(3)

                    except Exception as e:
                        logger.error(f"Gemini scan error for {symbol}: {e}")

                # Market overview (after individual analyses)
                try:
                    await self.market_overview(
                        pairs=pairs,
                        session_phase=session_phase,
                        weekly_act=weekly_act,
                        pairs_data=pairs_data,
                        account_balance=balance,
                        account_equity=equity,
                        open_count=len(open_positions),
                    )
                except Exception as e:
                    logger.error(f"Gemini market overview error: {e}")

                logger.info(
                    f"[GEMINI] Scan cycle complete â€” "
                    f"{len(self._analysis_cache)} pairs analyzed, "
                    f"API calls today: {self._daily_calls}/{self._daily_limit}"
                )

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Gemini scan loop error: {e}")
                await asyncio.sleep(30)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #  DATA ACCESS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_analysis(self, symbol: str) -> Optional[Dict]:
        """Get the latest AI analysis for a symbol."""
        a = self._analysis_cache.get(symbol)
        return a.to_dict() if a else None

    def get_all_analyses(self) -> Dict[str, Dict]:
        """Get all cached AI analyses."""
        return {sym: a.to_dict() for sym, a in self._analysis_cache.items()}

    def get_overview(self) -> Optional[Dict]:
        """Get the latest market overview."""
        return self._overview_cache

    def get_signal_reviews(self, limit: int = 10) -> List[Dict]:
        """Get recent signal reviews."""
        return [r.to_dict() for r in self._signal_reviews[-limit:]]

    def get_ai_trade_signals(self, limit: int = 10) -> List[Dict]:
        """Get recent AI-generated trade signals."""
        return [s.to_dict() for s in self._ai_trade_signals[-limit:]]

    def get_full_state(self) -> Dict[str, Any]:
        """Get the complete AI advisor state for the dashboard."""
        return {
            "status": self.status,
            "analyses": self.get_all_analyses(),
            "overview": self.get_overview(),
            "signal_reviews": self.get_signal_reviews(),
            "ai_trade_signals": self.get_ai_trade_signals(),
        }

    async def cleanup(self):
        """Cleanup resources."""
        await self.stop_scan_loop()
        if self._client:
            await self._client.aclose()
            self._client = None
